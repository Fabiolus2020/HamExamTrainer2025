<!DOCTYPE html>
<html lang="en">
<head>
<meta name="theme-color" content="#121212">
<link rel="manifest" href="manifest.json">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta charset="UTF-8">
<title>Amateur Radio Exam Practice</title>
<style>
/* Base layout */
body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  max-width: 900px;
  margin: 24px auto;
  padding: 16px;
  line-height: 1.6;
  background: #f4f5fb;
  color: #1f2933;
}

h1 {
  text-align: center;
  font-size: 1.9rem;
  margin: 0 0 12px 0;
  letter-spacing: 0.02em;
}

/* Card containers */
.card {
  background: #ffffff;
  border-radius: 14px;
  padding: 18px 20px;
  margin-top: 18px;
  box-shadow: 0 10px 25px rgba(15, 23, 42, 0.08);
  border: 1px solid rgba(148, 163, 184, 0.4);
}

/* Control rows */
.controls {
  margin-top: 12px;
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}

/* Buttons */
button {
  padding: 8px 14px;
  border-radius: 999px;
  border: 1px solid transparent;
  background: #e5e7eb;
  color: #111827;
  cursor: pointer;
  font-size: 0.95rem;
  font-weight: 500;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  transition:
    background 0.15s ease,
    color 0.15s ease,
    transform 0.1s ease,
    box-shadow 0.15s ease,
    border-color 0.15s ease;
}

button:hover:not(:disabled) {
  transform: translateY(-1px);
  box-shadow: 0 4px 10px rgba(15, 23, 42, 0.18);
}

button:disabled {
  opacity: 0.65;
  cursor: not-allowed;
  box-shadow: none;
}

.btn-primary {
  background: #4f46e5;
  color: #ffffff;
  border-color: #4f46e5;
  box-shadow: 0 6px 14px rgba(79, 70, 229, 0.35);
}

.btn-primary:hover:not(:disabled) {
  background: #4338ca;
  border-color: #4338ca;
}

.btn-secondary {
  background: #f9fafb;
  color: #111827;
  border-color: #d1d5db;
}

.btn-secondary:hover:not(:disabled) {
  background: #e5e7eb;
}

.btn-ghost {
  background: transparent;
  color: #4b5563;
  border-color: transparent;
  box-shadow: none;
}

.btn-ghost:hover:not(:disabled) {
  background: rgba(148, 163, 184, 0.15);
}

.btn-danger {
  background: #b91c1c;
  color: #fef2f2;
  border-color: #b91c1c;
}

.btn-danger:hover:not(:disabled) {
  background: #991b1b;
  border-color: #991b1b;
}
/* Status & meta text */
#memoryConsolidation {
  margin-top: 10px;
  font-size: 0.9rem;
  color: #374151;
}

#memoryConsolidation h4 {
  margin: 0 0 4px 0;
  font-size: 0.95rem;
}

#memoryConsolidation ul {
  margin: 4px 0 0 18px;
  padding: 0;
}

#memoryConsolidation li {
  margin-bottom: 2px;
}

body.dark #memoryConsolidation {
  color: #e5e7eb;
}

#status {
  margin-top: 8px;
  font-size: 0.95rem;
  color: #4b5563;
}

#bankQuestionId {
  font-weight: 600;
  margin-bottom: 4px;
  color: #374151;
}

#questionText {
  font-weight: 600;
  margin-bottom: 10px;
  font-size: 1.05rem;
}

/* Answer options */
.option-label {
  display: block;
  margin-bottom: 6px;
  padding: 6px 10px;
  border-radius: 8px;
  border: 1px solid #e2e8f0;
  background: #f9fafb;
  transition:
    background 0.15s ease,
    border-color 0.15s ease,
    transform 0.05s ease;
}

.option-label:hover {
  background: #eef2ff;
  border-color: #c7d2fe;
}

.option-label.correct {
  background: #d1fae5;
  border-color: #34d399;
}

.option-label.incorrect {
  background: #fee2e2;
  border-color: #f87171;
}

/* Feedback */
#feedback {
  margin-top: 10px;
  font-weight: 600;
}

#feedback.correct {
  color: #15803d;
}

#feedback.incorrect {
  color: #b91c1c;
}

#explanation {
  margin-top: 6px;
  font-style: italic;
  color: #374151;
  white-space: pre-line;
}

#score {
  margin-top: 10px;
  font-size: 0.95rem;
}

#wrongInfo {
  font-size: 0.9rem;
  color: #4b5563;
}

/* Mode indicator badges */
#modeIndicator {
  margin-top: 4px;
  margin-bottom: 4px;
  text-align: center;
}

.mode-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 12px;
  border-radius: 999px;
  font-size: 0.85rem;
  font-weight: 500;
  background: #eef2ff;
  color: #1d4ed8;
  border: 1px solid #c7d2fe;
}

.badge-random {
  background: #eef2ff;
  color: #1d4ed8;
  border-color: #c7d2fe;
}

.badge-norepeat {
  background: #fffbeb;
  color: #b45309;
  border-color: #fed7aa;
}

.badge-exam {
  background: #fee2e2;
  color: #b91c1c;
  border-color: #fecaca;
}

.badge-category {
  background: #ecfdf5;
  color: #047857;
  border-color: #6ee7b7;
}

.badge-wrongonly {
  background: #fdf2ff;
  color: #7e22ce;
  border-color: #e9d5ff;
}

body.dark .mode-badge {
  background: #1f2937;
  color: #e5e7eb;
  border-color: #4b5563;
}

body.dark .badge-random {
  background: #1e293b;
  color: #bfdbfe;
  border-color: #60a5fa;
}

body.dark .badge-norepeat {
  background: #451a03;
  color: #fed7aa;
  border-color: #fdba74;
}

body.dark .badge-exam {
  background: #450a0a;
  color: #fecaca;
  border-color: #fca5a5;
}

body.dark .badge-category {
  background: #064e3b;
  color: #bbf7d0;
  border-color: #6ee7b7;
}

body.dark .badge-wrongonly {
  background: #4c1d95;
  color: #e9d5ff;
  border-color: #c4b5fd;
}
/* Sticky question header */
#stickyQuestionHeader {
  position: sticky;
  top: 0;
  z-index: 10;
  padding-bottom: 8px;
  margin-bottom: 10px;
  background: #ffffff;
  border-bottom: 1px solid #e5e7eb;
}

body.dark #stickyQuestionHeader {
  background: #111827;
  border-bottom-color: #374151;
}
/* Weak areas spotlight */
.weak-area-item {
  margin-top: 4px;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 6px;
}

.weak-badge {
  display: inline-block;
  padding: 3px 8px;
  border-radius: 999px;
  font-size: 0.85rem;
  background: #fee2e2;
  color: #b91c1c;
}

.weak-practice-btn {
  padding: 4px 10px;
  border-radius: 999px;
  border: 1px solid #4b5563;
  background: #f9fafb;
  cursor: pointer;
  font-size: 0.8rem;
}

/* Progress bar */
#progressContainer {
  margin: 6px 0 8px 0;
}

#progressLabel {
  font-size: 0.9rem;
  margin-bottom: 4px;
}

#progressBarOuter {
  width: 100%;
  height: 10px;
  background: #e5e7eb;
  border-radius: 999px;
  overflow: hidden;
}

#progressBarInner {
  height: 100%;
  width: 0%;
  background: #22c55e;
  transition: width 0.2s ease-out;
}


/* Category breakdown table with progress bars */
.cat-breakdown-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 8px;
  font-size: 0.9rem;
}

.cat-breakdown-table th,
.cat-breakdown-table td {
  padding: 6px 8px;
  border-bottom: 1px solid #e5e7eb;
  text-align: left;
  vertical-align: middle;
}

.cat-breakdown-table th {
  font-weight: 600;
}

.cat-progress-cell {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.cat-progress-label {
  font-size: 0.8rem;
  color: #374151;
}

.cat-progress-outer {
  width: 100%;
  height: 8px;
  background: #e5e7eb;
  border-radius: 999px;
  overflow: hidden;
}

.cat-progress-inner {
  height: 100%;
  width: 0%;
  background: #22c55e;
  transition: width 0.25s ease-out;
}

body.dark .cat-breakdown-table th,
body.dark .cat-breakdown-table td {
  border-bottom-color: #374151;
}

body.dark .cat-progress-outer {
  background: #374151;
}

body.dark .cat-progress-inner {
  background: #22c55e;
}

body.dark .cat-progress-label {
  color: #e5e7eb;
}

/* Recent accuracy dots */
#recentAccuracy {
  margin: 6px 0 4px 0;
  font-size: 0.85rem;
}


/* Color themes */
body.theme-default {
  /* uses base colors defined above */
}

body.theme-ocean .card {
  border-color: #0ea5e9;
}
body.theme-ocean .btn-primary {
  background: #0284c7;
  border-color: #0284c7;
  box-shadow: 0 6px 14px rgba(37, 99, 235, 0.35);
}
body.theme-ocean .btn-primary:hover:not(:disabled) {
  background: #0369a1;
  border-color: #0369a1;
}
body.theme-ocean .mode-badge,
body.theme-ocean .badge-random {
  background: #e0f2fe;
  color: #0369a1;
  border-color: #7dd3fc;
}
body.theme-ocean .cat-progress-inner {
  background: #0ea5e9;
}

body.theme-forest .card {
  border-color: #16a34a;
}
body.theme-forest .btn-primary {
  background: #15803d;
  border-color: #15803d;
  box-shadow: 0 6px 14px rgba(21, 128, 61, 0.35);
}
body.theme-forest .btn-primary:hover:not(:disabled) {
  background: #166534;
  border-color: #166534;
}
body.theme-forest .mode-badge,
body.theme-forest .badge-random {
  background: #dcfce7;
  color: #166534;
  border-color: #6ee7b7;
}
body.theme-forest .cat-progress-inner {
  background: #22c55e;
}

body.theme-amber .card {
  border-color: #f59e0b;
}
body.theme-amber .btn-primary {
  background: #d97706;
  border-color: #d97706;
  box-shadow: 0 6px 14px rgba(217, 119, 6, 0.35);
}
body.theme-amber .btn-primary:hover:not(:disabled) {
  background: #b45309;
  border-color: #b45309;
}
body.theme-amber .mode-badge,
body.theme-amber .badge-random {
  background: #fffbeb;
  color: #92400e;
  border-color: #fed7aa;
}
body.theme-amber .cat-progress-inner {
  background: #f59e0b;
}

body.theme-highcontrast {
  background: #ffffff;
  color: #000000;
}
body.theme-highcontrast .card {
  background: #ffffff;
  border-color: #000000;
  box-shadow: none;
}
body.theme-highcontrast .btn-primary {
  background: #000000;
  border-color: #000000;
  color: #ffffff;
}
body.theme-highcontrast .btn-secondary {
  background: #ffffff;
  border-color: #000000;
  color: #000000;
}
body.theme-highcontrast .mode-badge {
  background: #000000;
  color: #ffffff;
  border-color: #000000;
}
body.theme-highcontrast .cat-progress-outer {
  background: #d1d5db;
}
body.theme-highcontrast .cat-progress-inner {
  background: #000000;
}

/* Dark mode */
body.dark {
  background-color: #020617;
  color: #e5e7eb;
}

body.dark .card {
  background: #111827;
  border-color: #1f2937;
  box-shadow: 0 18px 40px rgba(0, 0, 0, 0.6);
}

body.dark #status {
  color: #9ca3af;
}

body.dark .option-label {
  background: #111827;
  border-color: #374151;
}

body.dark .option-label.correct {
  background: #065f46;
  border-color: #22c55e;
}

body.dark .option-label.incorrect {
  background: #7f1d1d;
  border-color: #f97373;
}

body.dark .weak-badge {
  background: #7f1d1d;
  color: #fee2e2;
}

body.dark .weak-practice-btn {
  background: #111827;
  border-color: #9ca3af;
  color: #e5e7eb;
}

body.dark .btn-primary {
  background: #4f46e5;
  border-color: #6366f1;
  color: #f9fafb;
}

body.dark .btn-secondary {
  background: #111827;
  border-color: #374151;
  color: #e5e7eb;
}

body.dark .btn-ghost {
  color: #e5e7eb;
}

body.dark button:hover:not(:disabled) {
  box-shadow: 0 4px 10px rgba(15, 23, 42, 0.8);
}
body.mobile-mode .controls button {
  width: 100%;
  box-sizing: border-box;
}

body.mobile-mode button {
  font-size: 16px;
  padding: 10px 16px;
}

body.mobile-mode #modeControls label {
  display: block;
  margin: 4px 0;
}

#modeControls .mode-item {
  margin-top: 6px;
}
#modeControls label {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.95rem;
}

</style>
</head>
<body>
<button id="darkToggle" class="btn-ghost" style="position:fixed;top:10px;right:10px;z-index:999;">Dark Mode</button>
<button id="mobileToggle" class="btn-ghost" style="position:fixed;top:50px;right:10px;z-index:999;">Mobile Mode</button>
<button id="fullscreenToggle" class="btn-ghost" style="position:fixed;top:90px;right:10px;z-index:999;">Full screen</button>
<h1>Amateur Radio Exam Practice</h1>

<div class="card">
  <p id="step1Text"><strong>Step 1:</strong> Choose your preferred language.</p>
  <div id="languageControls" style="margin-bottom:10px;">
    <label><input type="radio" name="lang" id="langEn" value="en" checked> English</label>
    <label style="margin-left: 10px;"><input type="radio" name="lang" id="langFr" value="fr"> Fran√ßais</label>
  </div>

  <div id="themeControls" style="margin-bottom:10px;">
    <label for="themeSelect">Theme:</label>
    <select id="themeSelect">
      <option value="default">Default</option>
      <option value="ocean">Ocean</option>
      <option value="forest">Forest</option>
      <option value="amber">Amber</option>
      <option value="highcontrast">High contrast</option>
    </select>
  </div>

  <p id="step2Text"><strong>Step 2:</strong> Load the official ISED question bank file <code>amat_basic_quest_delim.txt</code> or a compatible CSV file.</p>
  <div id="officialLoadButtons" class="controls" style="margin-top:6px;margin-bottom:6px;">
    <button type="button" id="loadBasicBtn" class="btn-primary">Load official Basic bank (from GitHub)</button>
    <button type="button" id="loadAdvancedBtn" class="btn-primary">Load official Advanced bank (from GitHub)</button>
    <button type="button" id="downloadCsvBtn" class="btn-secondary">Download explanation CSV (from GitHub)</button>
  </div>
  <!-- New bilingual GitHub note -->
  <p id="githubNote" style="font-size:0.85rem; color:#555; margin-top:4px;">
    Requires internet to load from GitHub.
  </p>

  <input type="file" id="fileInput" accept=".csv,.txt">
  <p id="localFileNote" style="font-size:0.85rem; color:#555; margin-top:4px;">Use this option to load a local file.</p>
  <div id="status">No file loaded.</div>

  <p id="step3Text"><strong>Step 3:</strong> Select the desired question mode (Random, No repeats, or Exam).</p>
  <div id="modeControls" style="margin-top:8px;">
  <strong id="modeLabel">Question mode:</strong>

  <div class="mode-item">
    <label><input type="radio" name="mode" id="modeRandom" value="random" checked>
      <span id="labelRandom">Random</span>
    </label>
  </div>

  <div class="mode-item">
    <label><input type="radio" name="mode" id="modeNoRepeat" value="norepeat">
      <span id="labelNoRepeat">No repeats until all questions used</span>
    </label>
  </div>

  <div class="mode-item">
    <label><input type="radio" name="mode" id="modeExam" value="exam">
      <span id="labelExam">Exam (up to 100 questions)</span>
    </label>
  </div>

  <div class="mode-item">
    <label><input type="radio" name="mode" id="modeCategory" value="category">
      <span id="labelCategory">Category training</span>
    </label>
  </div>
</div>

  
  <div id="categoryTrainingContainer" style="margin-top:8px; display:none;">
    <strong id="categoryTrainingTitle">Category training</strong>
    <div id="categoryCheckboxes" style="margin-top:4px;"></div>
    <p id="categoryHint" style="font-size:0.85rem; margin-top:4px;"></p>
  </div>
  <p id="step4Text"><strong>Step 4:</strong> Click <em>Next Question</em> to start the quiz.</p>
</div>

<div class="card" id="quizCard" style="display:none;">
<div id="stickyQuestionHeader">
<div id="questionHeader">
<span id="questionCounter"></span>
</div>
<div id="modeIndicator" style="text-align:center; margin:6px 0;"></div>

<!-- Progress & motivation UI -->
<div id="progressContainer">
  <div id="progressLabel"></div>
  <div id="progressBarOuter">
    <div id="progressBarInner"></div>
  </div>
</div>
<div id="bankQuestionId"></div>
</div>
<div id="questionText"></div>
<form id="optionsForm">
<div id="options"></div>
</form>

<div id="feedback"></div>
<div id="explanation"></div>

<div class="controls">
<button id="checkBtn" class="btn-primary">Check Answer</button>
<button id="nextBtn" class="btn-primary" disabled>Next Question</button>
<button id="resetBtn" type="button" class="btn-secondary">Reset</button>
</div>

<div id="score"></div>
<div id="memoryConsolidation"></div>
<div id="categoryReport"></div>
</div>



<script>
// Data structure:
// {
// bankID, // BankQuestionID (string, may be empty)
// question,
// options: [A,B,C,D],
// correctIndex,
// explanation,
// raw: {
// bankID,
// question,
// optionA,
// optionB,
// optionC,
// optionD,
// correctLetter,
// explanation
// }
// }
let questions = [];
let currentQuestionIndex = null;
let totalAsked = 0;
let totalCorrect = 0;

let recentResults = []; // store last 20 results as booleans

let wrongQuestionIndices = new Set(); // indices of questions answered incorrectly

let categorySelection = new Set(); // selected category codes for training mode

// Exam profile: 'basic' (B-xxx IDs), 'advanced' (A-xxx IDs), or 'basic' by default
let examProfile = 'basic';

// Category definitions: bilingual labels for BASIC and ADVANCED
const CATEGORY_INFO_BASIC = {
  '001': { en: 'Regulations and Policies', fr: 'R√®glements et politiques' },
  '002': { en: 'Operating and Procedures', fr: 'Exploitation et proc√©dures' },
  '003': { en: 'Station Assembly, Practice and Safety', fr: 'Montage de la station, pratique et s√©curit√©' },
  '004': { en: 'Circuit Components', fr: 'Composants de circuits' },
  '005': { en: 'Basic Electronics and Theory', fr: '√âlectronique de base et th√©orie' },
  '006': { en: 'Feedlines and Antenna Systems', fr: 'Lignes d‚Äôalimentation et syst√®mes d‚Äôantenne' },
  '007': { en: 'Radio Wave Propagation', fr: 'Propagation des ondes radio' },
  '008': { en: 'Interference and Suppression', fr: 'Brouillage et suppression' }
};

const CATEGORY_INFO_ADVANCED = {
  '001': { en: 'Advanced Theory', fr: 'Th√©orie avanc√©e' },
  '002': { en: 'Advanced Components and Circuits', fr: 'Composants et circuits avanc√©s' },
  '003': { en: 'Measurements', fr: 'Mesures' },
  '004': { en: 'Power Supplies', fr: 'Alimentations' },
  '005': { en: 'Transmitters, Modulation and Processing', fr: '√âmetteurs, modulation et traitement' },
  '006': { en: 'Receivers', fr: 'R√©cepteurs' },
  '007': { en: 'Feedlines, Matching and Antenna Systems', fr: 'Lignes d‚Äôalimentation, adaptation et syst√®mes d‚Äôantenne' }
};

function getCurrentCategoryInfo() {
  return examProfile === 'advanced' ? CATEGORY_INFO_ADVANCED : CATEGORY_INFO_BASIC;
}

function buildCategoryTrainingUI() {
  if (!categoryTrainingContainer || !categoryCheckboxesEl) return;
  const catInfo = getCurrentCategoryInfo();
  categoryCheckboxesEl.innerHTML = '';
  categorySelection = new Set();
  const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;

  // Build a checkbox for each known category
  for (const code in catInfo) {
    const labelObj = catInfo[code];
    const labelText = labelObj ? (labelObj[currentLanguage] || labelObj.en) : code;
    const wrapper = document.createElement('label');
    wrapper.style.display = 'block';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.value = code;
    cb.className = 'cat-checkbox';
    cb.addEventListener('change', () => {
      if (cb.checked) {
        categorySelection.add(code);
      } else {
        categorySelection.delete(code);
      }
    });
    const span = document.createElement('span');
    span.textContent = ' ' + code + ' - ' + labelText;
    wrapper.appendChild(cb);
    wrapper.appendChild(span);
    categoryCheckboxesEl.appendChild(wrapper);
  }
  // Do NOT change visibility here; that is handled by updateCategoryTrainingVisibility()
}

function updateCategoryTrainingVisibility() {
  if (typeof categoryTrainingContainer === 'undefined' || !categoryTrainingContainer) return;
  if (selectionMode === 'category' && questions && questions.length > 0) {
    categoryTrainingContainer.style.display = 'block';
  } else {
    categoryTrainingContainer.style.display = 'none';
  }
}

// Per-exam category statistics
let categoryStats = {};
let cycleAnsweredCount = 0;

let currentLanguage = 'en';
let storedLang = null;
try {
  storedLang = window.localStorage ? window.localStorage.getItem('hamExamLang') : null;
} catch (e) {
  storedLang = null;
}
if (storedLang === 'en' || storedLang === 'fr') {
  currentLanguage = storedLang;
}

let currentTheme = 'default';
let selectionMode = 'random';
let questionSequence = [];
let questionSequencePosition = 0;
let isMobileMode = false;
let isFullScreen = false;

let lastBankSource = null; // 'official-basic', 'official-advanced', 'official-other', 'local'
let lastBankUrl = null;
let lastBankFileName = null;
let lastBankText = null;

const UI_STRINGS = {
  en: {
    title: 'Amateur Radio Exam Practice',
    step1: 'Step 1: Choose your preferred language.',
    step2: 'Step 2: Load a question bank. You can either use the GitHub buttons below (official Basic / Advanced banks) or select a local TXT/CSV file.',
    step3: 'Step 3: Select the desired question mode (Random, No repeats, or Exam).',
    step4: 'Step 4: Click "Next Question" to start the quiz.',
    loadBasicBtn: 'Load official Basic bank (from GitHub)',
    loadAdvancedBtn: 'Load official Advanced bank (from GitHub)',
    githubNote: 'Requires internet to load from GitHub.',
    localFileNote: 'Use this option to load a local file.',
    modeLabel: 'Question mode:',
    randomLabel: 'Random',
    noRepeatLabel: 'No repeats until all questions used',
    examLabelBasic: 'Exam (official structure: 100 questions)',
    examLabelAdvanced: 'Exam (official structure: 50 questions)',
    statusNoFile: 'No file loaded.',
    statusExamMode: 'Exam mode: official exam-style question set selected from the loaded bank.',
    statusNoValid: 'No valid questions found in the file. Check the format.',
    statusErrorFile: 'Error reading the file. Check the format and try again.',
    statusExamComplete: 'Exam complete: you have answered all questions in this exam set.',
    statusAllSeen: 'You have seen all questions once. Starting a new shuffled cycle.',
    feedbackCorrect: 'Correct!',
    feedbackIncorrect: 'Incorrect.',
    explanationLabel: 'Explanation:',
    wrongNone: 'You haven‚Äôt missed any questions yet.',
    wrongSome: 'You have missed {N} unique question(s). You can download them as a CSV and re-upload later to practice only those.',
    wrongTitle: 'Wrong Questions Tracker',
    wrongDownload: 'Download wrong questions CSV',
    scorePrefix: 'Score',
    resetBtn: 'Reset',
    progressLabel: 'Progress',
    progressExamSuffix: ' (exam set)',
    progressNoRepeatSuffix: ' (cycle)',
    progressRandomSuffix: '',
    recentAccuracyLabel: 'Recent answers (last 20):',
    passHonours: ' ‚Äî Pass with honours: ',
    pass: ' ‚Äî Pass: ',
    belowPass: ' ‚Äî Fail: ',
    catBreakdownTitle: 'Category Breakdown',
    catColCategory: 'Category',
    catColCorrect: 'Correct Answers',
    catColQuestions: 'Questions',
    catColPercent: 'Percent',
    weakAreasTitle: 'Weak areas (below 70%)',
    weakAreasNone: 'No weak areas detected ‚Äî great work!',
    weakBadgePrefix: 'Weak area detected: ',
    weakPracticeBtn: 'Practice only this category',
    retakeWrongTitle: 'Retake wrong questions',
    retakeWrongBtn: 'Retake only wrong questions',
    retakeWrongDesc: 'Build a new quiz using only the questions you missed in this exam.',
    examReviewTitle: 'Exam review',
    examReviewIntro: 'Summary of each question in this exam set:',
    examReviewColQ: 'Question',
    examReviewColResult: 'Result',
    examReviewResultCorrect: 'Correct',
    examReviewResultIncorrect: 'Incorrect',
    statusRetakeWrong: 'Retake mode: practicing only questions you got wrong in the last exam.',
    selectAnswerPrompt: 'Please select an answer.',
    loadedMessage: 'Loaded {N} questions successfully.',
    checkBtn: 'Check Answer',
    nextBtn: 'Next Question',
    darkToggle: 'Dark Mode',
    questionCounterLabel: 'Question',
    mobileOn: 'Mobile Mode',
    mobileOff: 'Desktop Mode',
    modeRandomIndicator: 'üîÑ Current mode: Random',
    modeNoRepeatIndicator: '‚ôªÔ∏è Current mode: No repeats',
    modeExamIndicator: 'üéØ Current mode: Exam',
    modeCategoryIndicator: 'üìö Current mode: Category training',
    modeWrongOnlyIndicator: 'üîÅ Current mode: Retake wrong questions',
    categoryLabel: 'Category training',
    categoryTrainingTitle: 'Category training (by topic)',
    categoryHint: 'Select one or more categories (e.g., only Regulations, only Antennas, only Propagation), then click \"Next Question\".',
    supportTitle: 'About & Support',
    supportText: 'This free bilingual HAM exam trainer was created to help students prepare using real-style questions, official exam structures, and category statistics. It is licensed under CC BY-NC-SA 4.0 (non-commercial, attribution, share-alike). You may use and share it for personal or educational purposes, but not resell it or include it in paid products or services. If this app helps you, you can support future improvements.',
    supportButton: '‚òï Buy me a coffee',
    supportButtonUrl: 'https://buymeacoffee.com/fabiolus',
    supportExtra: 'Support my work: your donation helps me maintain and improve this free HAM exam trainer for the community.',
    supportIssueText: 'üêû Report an issue on GitHub',
    supportIssueUrl: 'https://github.com/Fabiolus2020/HamExamTrainer2025/issues',
    supportReadmeText: 'üìò View README on GitHub',
    supportReadmeUrl: 'https://raw.githubusercontent.com/Fabiolus2020/HamExamTrainer2025/main/README.md',
    downloadCsvBtn: 'Download explanation CSV (from GitHub)',
    licenseFooterHtml: 'Licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">CC BY-NC-SA 4.0</a> &ndash; Non-commercial use only',
fullScreenOn: 'Full screen',
fullScreenOff: 'Exit full screen',
  },
  fr: {
    title: 'Pratique pour l‚Äôexamen de radioamateur',
    step1: '√âtape 1 : Choisissez la langue de votre choix.',
    step2: '√âtape 2 : Chargez une banque de questions. Vous pouvez utiliser les boutons GitHub ci-dessous (banques officielle de base / avanc√©e) ou s√©lectionner un fichier TXT/CSV local.',
    step3: '√âtape 3 : S√©lectionnez le mode de questions souhait√© (Al√©atoire, Sans r√©p√©tition ou Examen).',
    step4: '√âtape 4 : Cliquez sur ¬´ Question suivante ¬ª pour commencer le quiz.',
    loadBasicBtn: 'Charger la banque de base officielle (depuis GitHub)',
    loadAdvancedBtn: 'Charger la banque avanc√©e officielle (depuis GitHub)',
    githubNote: 'N√©cessite une connexion Internet pour charger depuis GitHub.',
    localFileNote: 'Utilisez cette option pour charger un fichier local.',
    modeLabel: 'Mode de questions :',
    randomLabel: 'Al√©atoire',
    noRepeatLabel: 'Sans r√©p√©tition jusqu‚Äô√† ce que toutes les questions soient utilis√©es',
    examLabelBasic: 'Examen (structure officielle : 100 questions)',
    examLabelAdvanced: 'Examen (structure officielle : 50 questions)',
    statusNoFile: 'Aucun fichier charg√©.',
    statusExamMode: 'Mode examen : ensemble de questions de style officiel s√©lectionn√© √† partir de la banque charg√©e.',
    statusNoValid: 'Aucune question valide trouv√©e dans le fichier. V√©rifiez le format.',
    statusErrorFile: 'Erreur lors de la lecture du fichier. V√©rifiez le format et r√©essayez.',
    statusExamComplete: 'Examen termin√© : vous avez r√©pondu √† toutes les questions de cet ensemble.',
    statusAllSeen: 'Vous avez vu toutes les questions une fois. D√©marrage d‚Äôun nouveau cycle m√©lang√©.',
    feedbackCorrect: 'Bonne r√©ponse !',
    feedbackIncorrect: 'Mauvaise r√©ponse.',
    explanationLabel: 'Explication :',
    wrongNone: 'Vous n‚Äôavez encore manqu√© aucune question.',
    wrongSome: 'Vous avez manqu√© {N} question(s) unique(s). Vous pouvez les t√©l√©charger en CSV et les recharger plus tard pour pratiquer seulement celles-ci.',
    wrongTitle: 'Suivi des mauvaises r√©ponses',
    wrongDownload: 'T√©l√©charger les questions rat√©es en CSV',
    scorePrefix: 'R√©sultat',
    progressLabel: 'Progression',
    progressExamSuffix: ' (ensemble d‚Äôexamen)',
    progressNoRepeatSuffix: ' (cycle)',
    progressRandomSuffix: '',
    recentAccuracyLabel: 'R√©ponses r√©centes (20 derni√®res) :',
    passHonours: ' ‚Äî R√©ussite avec mention : ',
    pass: ' ‚Äî R√©ussite : ',
    belowPass: ' ‚Äî √âchec : ',
    catBreakdownTitle: 'R√©partition par cat√©gorie',
    catColCategory: 'Cat√©gorie',
    catColCorrect: 'Bonnes r√©ponses',
    catColQuestions: 'Questions',
    catColPercent: 'Pourcentage',
    weakAreasTitle: 'Points faibles (moins de 70 %)',
    weakAreasNone: 'Aucun point faible d√©tect√© ‚Äî excellent travail !',
    retakeWrongTitle: 'Revoir les mauvaises r√©ponses',
    retakeWrongBtn: 'Reprendre seulement les mauvaises r√©ponses',
    retakeWrongDesc: 'Cr√©er un nouveau quiz uniquement avec les questions rat√©es lors de cet examen.',
    examReviewTitle: 'Revue de l‚Äôexamen',
    examReviewIntro: 'R√©sum√© de chaque question de cet examen :',
    examReviewColQ: 'Question',
    examReviewColResult: 'R√©sultat',
    examReviewResultCorrect: 'Bonne r√©ponse',
    examReviewResultIncorrect: 'Mauvaise r√©ponse',
    statusRetakeWrong: 'Mode r√©vision : vous pratiquez seulement les questions rat√©es lors du dernier examen.',
    selectAnswerPrompt: 'Veuillez s√©lectionner une r√©ponse.',
    loadedMessage: 'Charg√© {N} questions avec succ√®s.',
    checkBtn: 'V√©rifier la r√©ponse',
    nextBtn: 'Question suivante',
    resetBtn: 'R√©initialiser',
    darkToggle: 'Mode sombre',
    questionCounterLabel: 'Question',
    mobileOn: 'Mode mobile',
    mobileOff: 'Mode standard',
    modeRandomIndicator: 'üîÑ Mode actuel : Al√©atoire',
    modeNoRepeatIndicator: '‚ôªÔ∏è Mode actuel : Sans r√©p√©tition',
    modeExamIndicator: 'üéØ Mode actuel : Examen',
    modeCategoryIndicator: 'üìö Mode actuel : Entra√Ænement par cat√©gorie',
    modeWrongOnlyIndicator: 'üîÅ Mode actuel : R√©vision des erreurs',
    categoryLabel: 'Entra√Ænement par cat√©gorie',
    categoryTrainingTitle: 'Entra√Ænement par cat√©gorie (par th√®me)',
    categoryHint: 'S√©lectionnez une ou plusieurs cat√©gories (par ex. seulement R√®glements, seulement Antennes, seulement Propagation), puis cliquez sur ¬´ Question suivante ¬ª.',
    supportTitle: '√Ä propos et soutien',
    supportText: 'Cet outil bilingue gratuit pour l‚Äôexamen de radioamateur vous aide √† vous pr√©parer avec des questions de style officiel, une structure r√©aliste et des statistiques par cat√©gorie. Il est diffus√© sous licence CC BY-NC-SA 4.0 (non commercial, attribution, partage dans les m√™mes conditions). Vous pouvez l‚Äôutiliser et le partager √† des fins personnelles ou √©ducatives, mais pas le revendre ni l‚Äôint√©grer √† des produits ou services payants. Si cet outil vous aide, vous pouvez soutenir les am√©liorations futures.',
    supportButton: '‚òï M‚Äôoffrir un caf√©',
    supportButtonUrl: 'https://buymeacoffee.com/fabiolus',
    supportExtra: 'Soutenez mon travail : votre contribution m‚Äôaide √† maintenir et am√©liorer gratuitement cet outil pour la communaut√© des radioamateurs.',
    supportIssueText: 'üêû Signaler un probl√®me sur GitHub',
    supportIssueUrl: 'https://github.com/Fabiolus2020/HamExamTrainer2025/issues',
    supportReadmeText: 'üìò Consulter le README sur GitHub',
    supportReadmeUrl: 'https://raw.githubusercontent.com/Fabiolus2020/HamExamTrainer2025/main/README.md',
    downloadCsvBtn: 'T√©l√©charger le CSV d‚Äôexplications (depuis GitHub)',
    licenseFooterHtml: 'Sous licence <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreferrer">CC BY-NC-SA 4.0</a> &ndash; Utilisation non commerciale uniquement',
    fullScreenOn: 'Plein √©cran',
    fullScreenOff: 'Quitter le mode plein √©cran'
  }
};



function getLoadedMessageWithProfile(strings) {
  const total = (questions && questions.length) ? questions.length : 0;
  if (currentLanguage === 'fr') {
    const profileLabel = examProfile === 'advanced'
      ? 'banque avanc√©e'
      : 'banque de base';
    return `Charg√© ${total} questions avec succ√®s depuis la ${profileLabel}.`;
  } else {
    const profileLabel = examProfile === 'advanced'
      ? 'Advanced bank'
      : 'Basic bank';
    return `Loaded ${total} questions successfully from the ${profileLabel}.`;
  }
}

function updateModeIndicator() {
  if (!modeIndicatorEl) return;
  // Only show mode indicator once a bank is loaded
  if (!questions || questions.length === 0) {
    modeIndicatorEl.innerHTML = '';
    return;
  }

  const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
  let badgeClass = '';
  let label = '';

  if (selectionMode === 'random') {
    label = strings.modeRandomIndicator;
    badgeClass = 'badge-random';
  } else if (selectionMode === 'norepeat') {
    label = strings.modeNoRepeatIndicator;
    badgeClass = 'badge-norepeat';
  } else if (selectionMode === 'exam') {
    label = strings.modeExamIndicator;
    badgeClass = 'badge-exam';
  } else if (selectionMode === 'category') {
    label = strings.modeCategoryIndicator || '';
    badgeClass = 'badge-category';
  } else if (selectionMode === 'wrongonly') {
    label = strings.modeWrongOnlyIndicator || '';
    badgeClass = 'badge-wrongonly';
  }

  if (!label) {
    modeIndicatorEl.innerHTML = '';
    return;
  }

  modeIndicatorEl.innerHTML = `<span class="mode-badge ${badgeClass}">${label}</span>`;
}

function applyTheme() {
  const body = document.body;
  body.classList.remove('theme-default', 'theme-ocean', 'theme-forest', 'theme-amber', 'theme-highcontrast');
  const cls = 'theme-' + (currentTheme || 'default');
  body.classList.add(cls);
}


function toggleFullscreen() {
  const doc = document;
  const docEl = document.documentElement;
  if (!doc.fullscreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
    if (docEl.requestFullscreen) {
      docEl.requestFullscreen();
    } else if (docEl.webkitRequestFullscreen) {
      docEl.webkitRequestFullscreen();
    } else if (docEl.msRequestFullscreen) {
      docEl.msRequestFullscreen();
    }
  } else {
    if (doc.exitFullscreen) {
      doc.exitFullscreen();
    } else if (doc.webkitExitFullscreen) {
      doc.webkitExitFullscreen();
    } else if (doc.msExitFullscreen) {
      doc.msExitFullscreen();
    }
  }
}


function applyLanguage() {
  const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
  if (appTitleEl) appTitleEl.textContent = strings.title;
  if (step1TextEl) step1TextEl.innerHTML = '<strong>' + strings.step1.split(':')[0] + ':</strong> ' + strings.step1.split(': ').slice(1).join(': ');
  if (step2TextEl) step2TextEl.innerHTML = '<strong>' + strings.step2.split(':')[0] + ':</strong> ' + strings.step2.split(': ').slice(1).join(': ');
  if (step3TextEl) step3TextEl.innerHTML = '<strong>' + strings.step3.split(':')[0] + ':</strong> ' + strings.step3.split(': ').slice(1).join(': ');
  if (step4TextEl) step4TextEl.innerHTML = '<strong>' + strings.step4.split(':')[0] + ':</strong> ' + strings.step4.split(': ').slice(1).join(': ');
  if (modeLabelEl) modeLabelEl.textContent = strings.modeLabel;
  if (labelRandomEl) labelRandomEl.textContent = strings.randomLabel;
  if (labelNoRepeatEl) labelNoRepeatEl.textContent = strings.noRepeatLabel;
  if (labelExamEl) {
    labelExamEl.textContent = examProfile === 'advanced' ? strings.examLabelAdvanced : strings.examLabelBasic;
  }
  if (loadBasicBtnEl && strings.loadBasicBtn) loadBasicBtnEl.textContent = strings.loadBasicBtn;
  if (loadAdvancedBtnEl && strings.loadAdvancedBtn) loadAdvancedBtnEl.textContent = strings.loadAdvancedBtn;
  if (downloadCsvBtnEl && strings.downloadCsvBtn) downloadCsvBtnEl.textContent = strings.downloadCsvBtn;
  if (labelCategoryEl && strings.categoryLabel) {
    labelCategoryEl.textContent = strings.categoryLabel;
  }
  if (categoryTrainingTitleEl && strings.categoryTrainingTitle) {
    categoryTrainingTitleEl.textContent = strings.categoryTrainingTitle;
  }
  if (categoryHintEl && strings.categoryHint) {
    categoryHintEl.textContent = strings.categoryHint;
  }
  // New: bilingual GitHub note
  if (document.getElementById("localFileNote") && strings.localFileNote) {
    document.getElementById("localFileNote").textContent = strings.localFileNote;
  }

  if (githubNoteEl && strings.githubNote) {
    githubNoteEl.textContent = strings.githubNote;
  }
  // Support / About card localization
  const supportTitleEl = document.getElementById('supportTitle');
  const supportTextEl = document.getElementById('supportText');
  const supportButtonEl = document.getElementById('supportButton');
  const supportExtraEl = document.getElementById('supportExtra');
  const supportIssueEl = document.getElementById('supportIssueLink');
  const supportReadmeEl = document.getElementById('supportReadmeLink');
  if (supportTitleEl && strings.supportTitle) supportTitleEl.textContent = strings.supportTitle;
  if (supportTextEl && strings.supportText) supportTextEl.textContent = strings.supportText;
  if (supportButtonEl) {
    if (strings.supportButton) supportButtonEl.textContent = strings.supportButton;
    if (strings.supportButtonUrl) supportButtonEl.href = strings.supportButtonUrl;
  }
  if (supportExtraEl && strings.supportExtra) supportExtraEl.textContent = strings.supportExtra;
  if (supportIssueEl) {
    if (strings.supportIssueText) supportIssueEl.textContent = strings.supportIssueText;
    if (strings.supportIssueUrl) supportIssueEl.href = strings.supportIssueUrl;
  }
  if (supportReadmeEl) {
    if (strings.supportReadmeText) supportReadmeEl.textContent = strings.supportReadmeText;
    if (strings.supportReadmeUrl) supportReadmeEl.href = strings.supportReadmeUrl;
  }
  const licenseFooterEl = document.getElementById('licenseFooter');
  if (licenseFooterEl && strings.licenseFooterHtml) {
    licenseFooterEl.innerHTML = strings.licenseFooterHtml;
  }
  if (checkBtn) checkBtn.textContent = strings.checkBtn;
  if (nextBtn) nextBtn.textContent = strings.nextBtn;
  if (resetBtn && strings.resetBtn) resetBtn.textContent = strings.resetBtn;
  if (darkToggleBtn) darkToggleBtn.textContent = strings.darkToggle;
  if (mobileToggleBtn) {
    mobileToggleBtn.textContent = isMobileMode ? strings.mobileOff : strings.mobileOn;
  }
if (fullscreenToggleBtn && strings.fullScreenOn && strings.fullScreenOff) {
  fullscreenToggleBtn.textContent = isFullScreen ? strings.fullScreenOff : strings.fullScreenOn;
}
  if (statusEl && totalAsked === 0 && (!questions || questions.length === 0)) {
    statusEl.textContent = strings.statusNoFile;
  }
    // Update mode indicator based on current mode and language
  updateModeIndicator();
  // If questions are loaded and we are in category mode, keep the container visible; otherwise hide it
  updateCategoryTrainingVisibility();
  // Update progress & recent accuracy labels for current language
  updateProgressUI();
document.documentElement.lang = currentLanguage;
}




const fileInput = document.getElementById('fileInput');
const statusEl = document.getElementById('status');
const loadBasicBtnEl = document.getElementById('loadBasicBtn');
const loadAdvancedBtnEl = document.getElementById('loadAdvancedBtn');
const downloadCsvBtnEl = document.getElementById('downloadCsvBtn');

const quizCard = document.getElementById('quizCard');
const bankQuestionIdEl = document.getElementById('bankQuestionId');
const questionTextEl = document.getElementById('questionText');
const optionsEl = document.getElementById('options');
const optionsForm = document.getElementById('optionsForm');
const feedbackEl = document.getElementById('feedback');
const explanationEl = document.getElementById('explanation');
const questionCounterEl = document.getElementById('questionCounter');
const progressLabelEl = document.getElementById('progressLabel');
const progressBarInnerEl = document.getElementById('progressBarInner');
const recentAccuracyEl = document.getElementById('recentAccuracy');
const scoreEl = document.getElementById('score');
const checkBtn = document.getElementById('checkBtn');
const nextBtn = document.getElementById('nextBtn');
const resetBtn = document.getElementById('resetBtn');
const modeRandomRadio = document.getElementById('modeRandom');
const modeNoRepeatRadio = document.getElementById('modeNoRepeat');
const modeExamRadio = document.getElementById('modeExam');
const langEnRadio = document.getElementById('langEn');
const langFrRadio = document.getElementById('langFr');
const appTitleEl = document.querySelector('h1');
const themeSelectEl = document.getElementById('themeSelect');
const step1TextEl = document.getElementById('step1Text');
const step2TextEl = document.getElementById('step2Text');
const step3TextEl = document.getElementById('step3Text');
const step4TextEl = document.getElementById('step4Text');
const modeLabelEl = document.getElementById('modeLabel');
const labelRandomEl = document.getElementById('labelRandom');
const labelNoRepeatEl = document.getElementById('labelNoRepeat');
const labelExamEl = document.getElementById('labelExam');
const labelCategoryEl = document.getElementById('labelCategory');
const modeIndicatorEl = document.getElementById('modeIndicator');
const wrongTitleEl = document.getElementById('wrongTitle');
const darkToggleBtn = document.getElementById('darkToggle');
const mobileToggleBtn = document.getElementById('mobileToggle');
const fullscreenToggleBtn = document.getElementById('fullscreenToggle');
const modeCategoryRadio = document.getElementById('modeCategory');
const categoryTrainingContainer = document.getElementById('categoryTrainingContainer');
const categoryCheckboxesEl = document.getElementById('categoryCheckboxes');
const categoryTrainingTitleEl = document.getElementById('categoryTrainingTitle');
const categoryHintEl = document.getElementById('categoryHint');
const githubNoteEl = document.getElementById('githubNote'); // NEW: GitHub note element

// Hook up language radio buttons
if (langEnRadio && langFrRadio) {
  // Set initial checked state based on stored / current language
  if (currentLanguage === 'fr') {
    langFrRadio.checked = true;
    langEnRadio.checked = false;
  } else {
    langEnRadio.checked = true;
    langFrRadio.checked = false;
  }

  langEnRadio.addEventListener('change', () => {
    if (langEnRadio.checked) {
      currentLanguage = 'en';
      try {
        if (window.localStorage) {
          window.localStorage.setItem('hamExamLang', currentLanguage);
        }
      } catch (e) {}
      applyLanguage();
      if (currentQuestionIndex !== null) {
        // Redraw current question in new language
        showCurrentQuestionOnly();
      }
    }
  });
  langFrRadio.addEventListener('change', () => {
    if (langFrRadio.checked) {
      currentLanguage = 'fr';
      try {
        if (window.localStorage) {
          window.localStorage.setItem('hamExamLang', currentLanguage);
        }
      } catch (e) {}
      applyLanguage();
      if (currentQuestionIndex !== null) {
        showCurrentQuestionOnly();
      }
    }
  });
}

if (themeSelectEl) {
  themeSelectEl.addEventListener('change', () => {
    currentTheme = themeSelectEl.value || 'default';
    applyTheme();
  });
}

modeRandomRadio.addEventListener('change', () => {
  if (modeRandomRadio.checked) {
    selectionMode = 'random';
    const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
    if (questions && questions.length > 0) {
      statusEl.textContent = getLoadedMessageWithProfile(strings);
    } else {
      statusEl.textContent = strings.statusNoFile;
    }
    updateModeIndicator();
    updateCategoryTrainingVisibility();
    saveSessionState();
  }
});

modeNoRepeatRadio.addEventListener('change', () => {
  if (modeNoRepeatRadio.checked) {
    selectionMode = 'norepeat';
    resetQuestionSequence();
    const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
    if (questions && questions.length > 0) {
      statusEl.textContent = getLoadedMessageWithProfile(strings);
    } else {
      statusEl.textContent = strings.statusNoFile;
    }
    updateModeIndicator();
    updateCategoryTrainingVisibility();
    saveSessionState();
  }
});

modeExamRadio.addEventListener('change', () => {
  if (modeExamRadio.checked) {
    selectionMode = 'exam';
    // Reset stats for a fresh exam session
    totalAsked = 0;
    totalCorrect = 0;
    recentResults = [];
    wrongQuestionIndices = new Set();
    updateScore();
updateProgressUI();
  saveSessionState();

    resetQuestionSequence();
    if (categoryReportEl) {
      categoryReportEl.innerHTML = '';
    }
    statusEl.textContent = (UI_STRINGS[currentLanguage] || UI_STRINGS.en).statusExamMode;
    saveSessionState();
    nextBtn.disabled = false;
    updateModeIndicator();
    updateCategoryTrainingVisibility();
    saveSessionState();
  }
});

if (modeCategoryRadio) {
  modeCategoryRadio.addEventListener('change', () => {
    if (modeCategoryRadio.checked) {
      selectionMode = 'category';
      const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
      if (!questions || questions.length === 0) {
        statusEl.textContent = strings.statusNoFile;
        updateCategoryTrainingVisibility();
        return;
      }
      // Reset stats like a focused training session, but keep overall totals if desired
      resetQuestionSequence();
      statusEl.textContent = getLoadedMessageWithProfile(strings);
      // (Re)build the list of category checkboxes whenever we enter category mode
      buildCategoryTrainingUI();
      updateModeIndicator();
      updateCategoryTrainingVisibility();
      saveSessionState();
    }
  });
}

const categoryReportEl = document.getElementById('categoryReport');

// Initial language apply once the full DOM is ready (ensures footer hyperlink is active)
document.addEventListener('DOMContentLoaded', () => {
  applyLanguage();
  applyTheme();
  tryRestoreSession();
});

fileInput.addEventListener('change', handleFileSelect);
// Load official banks directly from GitHub (raw URLs)
const OFFICIAL_BASIC_URL = 'https://raw.githubusercontent.com/Fabiolus2020/HamExamTrainer2025/main/BankQuestions/amat_basic_quest_delim2025.txt';
const OFFICIAL_ADVANCED_URL = 'https://raw.githubusercontent.com/Fabiolus2020/HamExamTrainer2025/main/BankQuestions/amat_adv_quest_delim2025.txt';

function loadOfficialBank(url) {
  const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
  statusEl.textContent = 'Loading official bank from GitHub...';
  fetch(url)
    .then(resp => {
      if (!resp.ok) throw new Error('HTTP ' + resp.status);
      return resp.text();
    })
    .then(text => {
      try {
        // Official banks are ISED-style delimited TXT
        const parsed = parseISEDDelimitedQuestions(text);
        if (!parsed || parsed.length === 0) {
          statusEl.textContent = strings.statusNoValid;
          quizCard.style.display = 'none';
          return;
        }
        questions = parsed;
        detectProfileFromQuestions(questions);
        applyLanguage();
        statusEl.textContent = getLoadedMessageWithProfile(strings);
        quizCard.style.display = 'block';

        totalAsked = 0;
        totalCorrect = 0;
        recentResults = [];
        wrongQuestionIndices = new Set();
        updateScore();
        updateProgressUI();

        resetQuestionSequence();
        resetFeedback();
        clearQuestion();
        nextBtn.disabled = false;
        checkBtn.disabled = true;

        // Track bank source for session restore (official)
        if (url === OFFICIAL_BASIC_URL) {
          lastBankSource = 'official-basic';
        } else if (url === OFFICIAL_ADVANCED_URL) {
          lastBankSource = 'official-advanced';
        } else {
          lastBankSource = 'official-other';
        }
        lastBankUrl = url;
        lastBankFileName = null;
        lastBankText = null;
        saveSessionState();
      } catch (err) {
        console.error(err);
        statusEl.textContent = strings.statusErrorFile;
        quizCard.style.display = 'none';
      }
    })
    .catch(err => {
      console.error(err);
      statusEl.textContent = strings.statusErrorFile;
      quizCard.style.display = 'none';
    });
}

if (loadBasicBtnEl) {
  loadBasicBtnEl.addEventListener('click', () => {
    loadOfficialBank(OFFICIAL_BASIC_URL);
  });
}

if (loadAdvancedBtnEl) {
  loadAdvancedBtnEl.addEventListener('click', () => {
    loadOfficialBank(OFFICIAL_ADVANCED_URL);
  });
}

if (downloadCsvBtnEl) {
  downloadCsvBtnEl.addEventListener('click', () => {
    // Open the official explanation CSV (raw GitHub link)
    window.open('https://raw.githubusercontent.com/Fabiolus2020/HamExamTrainer2025/main/BankQuestions/BankQuestionJuly2025.csv', '_blank');
  });
}

checkBtn.addEventListener('click', handleCheckAnswer);
nextBtn.addEventListener('click', showNextQuestion);
resetBtn.addEventListener('click', resetApp);

// === Real CSV parser that supports:
// - commas in fields
// - quotes
// - double quotes ("") as escaped quotes
// - multi-line fields (line breaks inside quoted fields)
function parseCsvText(text) {
const rows = [];
let row = [];
let field = '';
let inQuotes = false;

for (let i = 0; i < text.length; i++) {
const ch = text[i];

if (inQuotes) {
if (ch === '"') {
// Check for escaped quote ("")
if (i + 1 < text.length && text[i + 1] === '"') {
field += '"';
i++; // skip the second quote
} else {
inQuotes = false;
}
} else {
field += ch;
}
} else {
if (ch === '"') {
inQuotes = true;
} else if (ch === ',') {
row.push(field);
field = '';
} else if (ch === '\r' || ch === '\n') {
// End of record (if we are not in quotes)
row.push(field);
field = '';
// Only push non-empty rows (or rows with at least one non-empty cell)
if (row.some(cell => cell.trim() !== '')) {
rows.push(row);
}
row = [];
// Skip \n after \r for CRLF
if (ch === '\r' && i + 1 < text.length && text[i + 1] === '\n') {
i++;
}
} else {
field += ch;
}
}
}

// Last field / last row
if (field.length > 0 || row.length > 0) {
row.push(field);
if (row.some(cell => cell.trim() !== '')) {
rows.push(row);
}
}

return rows;
}

function handleFileSelect(event) {
const file = event.target.files[0];
if (!file) return;

const reader = new FileReader();
reader.onload = function(e) {
const text = e.target.result;
try {
let isTxt = file.name.toLowerCase().endsWith('.txt');
if (isTxt) {
  questions = parseISEDDelimitedQuestions(text);
} else {
  questions = parseCsvToQuestions(text);
}
if (questions.length === 0) {
const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
statusEl.textContent = strings.statusNoValid;
quizCard.style.display = 'none';
} else {
const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
detectProfileFromQuestions(questions);
applyLanguage();
statusEl.textContent = getLoadedMessageWithProfile(strings);
quizCard.style.display = 'block';

totalAsked = 0;
totalCorrect = 0;
recentResults = [];
wrongQuestionIndices = new Set();
updateScore();
updateProgressUI();

resetQuestionSequence();
resetFeedback();
clearQuestion();
nextBtn.disabled = false;
checkBtn.disabled = true;

// Track bank source for session restore (local file)
lastBankSource = 'local';
lastBankUrl = null;
lastBankFileName = file.name || null;
lastBankText = text;
saveSessionState();
}
} catch (err) {
console.error(err);
statusEl.textContent = (UI_STRINGS[currentLanguage] || UI_STRINGS.en).statusErrorFile;
quizCard.style.display = 'none';
}
};
reader.readAsText(file);
}
function detectProfileFromQuestions(qs) {
  let hasBasic = false;
  let hasAdvanced = false;
  if (!qs) return;
  for (const q of qs) {
    if (!q || !q.bankID) continue;
    if (q.bankID.startsWith('B-')) hasBasic = true;
    else if (q.bankID.startsWith('A-')) hasAdvanced = true;
    if (hasBasic && hasAdvanced) break;
  }
  if (hasAdvanced && !hasBasic) {
    examProfile = 'advanced';
  } else if (hasBasic && !hasAdvanced) {
    examProfile = 'basic';
  } else {
    examProfile = 'basic';
  }
}

function parseISEDDelimitedQuestions(txt) {
  const lines = txt.split(/\r?\n/);
  if (!lines.length) return [];
  const result = [];
  // Expect header in lines[0]
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;
    const parts = line.split(';').map(p => p.trim());
    if (parts.length < 11) continue;
    const bankID = parts[0];
    const qEn = parts[1];
    const correctEn = parts[2];
    const inc1En = parts[3];
    const inc2En = parts[4];
    const inc3En = parts[5];
    const qFr = parts[6];
    const correctFr = parts[7];
    const inc1Fr = parts[8];
    const inc2Fr = parts[9];
    const inc3Fr = parts[10];

    if (!qEn || !correctEn) continue;

    const paired = [
      { en: correctEn, fr: correctFr, isCorrect: true },
      { en: inc1En, fr: inc1Fr, isCorrect: false },
      { en: inc2En, fr: inc2Fr, isCorrect: false },
      { en: inc3En, fr: inc3Fr, isCorrect: false }
    ];
    // Shuffle paired options
    for (let j = paired.length - 1; j > 0; j--) {
      const k = Math.floor(Math.random() * (j + 1));
      const tmp = paired[j];
      paired[j] = paired[k];
      paired[k] = tmp;
    }
    const optionsEn = paired.map(o => o.en);
    const optionsFr = paired.map(o => o.fr);
    const correctIndex = paired.findIndex(o => o.isCorrect);
    const category = getCategoryFromBankID(bankID);

    const q = {
      bankID,
      category,
      question: qEn,
      question_en: qEn,
      question_fr: qFr,
      options: optionsEn,
      options_en: optionsEn,
      options_fr: optionsFr,
      correctIndex,
      explanation: '',
      explanation_en: '',
      explanation_fr: '',
      raw: {
        bankID,
        category,
        question: qEn,
        optionA: optionsEn[0],
        optionB: optionsEn[1],
        optionC: optionsEn[2],
        optionD: optionsEn[3],
        correctLetter: indexToLetter(correctIndex),
        explanation: ''
      }
    };
    result.push(q);
  }
  return result;
}

function parseCsvToQuestions(csvText) {
const rows = parseCsvText(csvText);
const result = [];
if (!rows.length) return result;

const firstRow = rows[0];
const firstCell = (firstRow[0] || '').trim().toLowerCase();

const isVerticalFormat = firstRow.length >= 2 && firstCell === 'column';

if (isVerticalFormat) {
return parseVerticalQuestions(rows);
}

// Horizontal format: one row per question
let startIndex = 0;
if (firstCell.includes('question')) {
startIndex = 1; // skip header row
}

for (let i = startIndex; i < rows.length; i++) {
const cells = rows[i];
if (!cells || cells.length < 6) continue;

const question = (cells[0] || '').trim();
const optionA = (cells[1] || '').trim();
const optionB = (cells[2] || '').trim();
const optionC = (cells[3] || '').trim();
const optionD = (cells[4] || '').trim();
const correct = (cells[5] || '').trim();
const explanation = cells[6] ? cells[6].toString() : '';

// Optional BankQuestionID in horizontal format (column 8)
const bankID = cells[7] ? cells[7].toString().trim() : '';

if (!question || !optionA || !optionB || !optionC || !optionD || !correct) {
continue;
}

const correctIndex = letterToIndex(correct);
if (correctIndex === null) continue;
const correctLetter = indexToLetter(correctIndex);

const category = getCategoryFromBankID(bankID);

result.push({
bankID,
category,
question,
options: [optionA, optionB, optionC, optionD],
correctIndex,
explanation,
raw: {
bankID,
category,
question,
optionA,
optionB,
optionC,
optionD,
correctLetter,
explanation
}
});
}

return result;
}

// Extract category code (001‚Äì008) from BankQuestionID like "B-001-001-002"
function getCategoryFromBankID(bankId) {
if (!bankId) return null;
const m = bankId.match(/^[BA]-(\d{3})-/);
return m ? m[1] : null;
}

// Vertical format: header row "Column,Example", then key/value rows
function parseVerticalQuestions(rows) {
const result = [];
// rows[0] is header
let current = null;

function pushCurrent() {
if (!current) return;
if (!current.question || !current.optionA || !current.optionB ||
!current.optionC || !current.optionD || !current.correctLetter) {
return;
}
const correctIndex = letterToIndex(current.correctLetter);
if (correctIndex === null) return;

const bankID = current.bankID ? current.bankID.trim() : '';

const category = getCategoryFromBankID(bankID);

const q = {
bankID,
category,
question: current.question,
options: [current.optionA, current.optionB, current.optionC, current.optionD],
correctIndex,
explanation: current.explanation || '',
raw: {
bankID,
category,
question: current.question,
optionA: current.optionA,
optionB: current.optionB,
optionC: current.optionC,
optionD: current.optionD,
correctLetter: indexToLetter(correctIndex),
explanation: current.explanation || ''
}
};
result.push(q);
}

for (let i = 1; i < rows.length; i++) {
const row = rows[i];
if (!row || row.length < 2) continue;

const key = (row[0] || '').trim();
const value = (row[1] || '').toString(); // may contain \n inside

if (!key) continue;

const keyLower = key.toLowerCase();
if (keyLower === 'question') {
// New question; push previous if valid
if (current) pushCurrent();
current = {
bankID: '',
question: value.trim(),
optionA: '',
optionB: '',
optionC: '',
optionD: '',
correctLetter: '',
explanation: ''
};
} else if (current) {
if (keyLower === 'optiona') current.optionA = value.trim();
else if (keyLower === 'optionb') current.optionB = value.trim();
else if (keyLower === 'optionc') current.optionC = value.trim();
else if (keyLower === 'optiond') current.optionD = value.trim();
else if (keyLower === 'correctoption') current.correctLetter = value.trim();
else if (keyLower === 'explanation') current.explanation = value;
else if (keyLower === 'bankquestionid') current.bankID = value.trim();
}
}

if (current) pushCurrent();
return result;
}

function letterToIndex(letter) {
const l = letter.toString().trim().toUpperCase();
if (l === 'A') return 0;
if (l === 'B') return 1;
if (l === 'C') return 2;
if (l === 'D') return 3;
const num = parseInt(l, 10);
if (!isNaN(num) && num >= 0 && num <= 3) return num;
return null;
}

function indexToLetter(index) {
return String.fromCharCode(65 + index);
}


function buildExamQuestionSequence() {
  if (!questions || questions.length === 0) return [];

  // Build buckets of question indices by category code
  const catBuckets = {};
  for (let i = 0; i < questions.length; i++) {
    const q = questions[i];
    if (!q || !q.category) continue;
    if (!catBuckets[q.category]) catBuckets[q.category] = [];
    catBuckets[q.category].push(i);
  }

  // Official category quotas for Basic (100 questions) and Advanced (50 questions)
  const basicQuotas = {
    '001': 25,
    '002': 9,
    '003': 21,
    '004': 6,
    '005': 13,
    '006': 13,
    '007': 8,
    '008': 5
  };
  const advancedQuotas = {
    '001': 5,
    '002': 12,
    '003': 6,
    '004': 4,
    '005': 9,
    '006': 5,
    '007': 9
  };

  const quotas = (examProfile === 'advanced') ? advancedQuotas : basicQuotas;

  // Compute target total from quotas
  let targetTotal = 0;
  for (const code in quotas) {
    targetTotal += quotas[code];
  }

  // Local shuffle helper
  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
  }

  const selected = [];
  const used = new Set();

  // First, select per-category according to quotas
  for (const code in quotas) {
    const needed = quotas[code];
    const bucket = (catBuckets[code] || []).slice();
    if (bucket.length === 0 || needed <= 0) continue;
    shuffle(bucket);
    const take = Math.min(needed, bucket.length);
    for (let k = 0; k < take; k++) {
      const idx = bucket[k];
      if (!used.has(idx)) {
        selected.push(idx);
        used.add(idx);
      }
    }
  }

  // If we didn't reach the official target (e.g. custom/incomplete bank),
  // fill remaining slots with any leftover questions (any category) at random.
  if (selected.length < targetTotal) {
    const remaining = [];
    for (let i = 0; i < questions.length; i++) {
      if (!used.has(i)) remaining.push(i);
    }
    shuffle(remaining);
    for (let i = 0; i < remaining.length && selected.length < targetTotal; i++) {
      selected.push(remaining[i]);
      used.add(remaining[i]);
    }
  }

  // As a final safety, never exceed the total number of available questions.
  if (selected.length > questions.length) {
    return selected.slice(0, questions.length);
  }
  return selected;
}


function resetQuestionSequence() {
  // Reset per-cycle answered count for no-repeat and category training
  if (selectionMode === 'norepeat' || selectionMode === 'category') {
    cycleAnsweredCount = 0;
  }

  // Prepare a shuffled sequence of question indices for no-repeat or exam mode
  questionSequence = [];
  questionSequencePosition = 0;
  if (selectionMode !== 'norepeat' && selectionMode !== 'exam' && selectionMode !== 'category') {
    return;
  }
  if (!questions || questions.length === 0) {
    return;
  }
  const indices = [];
  for (let i = 0; i < questions.length; i++) {
    if (selectionMode === 'category') {
      const q = questions[i];
      if (!q || !q.category || !categorySelection.has(q.category)) continue;
    }
    indices.push(i);
  }
  // Fisher-Yates shuffle
  for (let i = indices.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = indices[i];
    indices[i] = indices[j];
    indices[j] = tmp;
  }
  if (selectionMode === 'exam') {
    // New exam: clear any previous wrong-question set
    wrongQuestionIndices = new Set();
    // Build an exam sequence that matches the official per-category distribution
    questionSequence = buildExamQuestionSequence();
    // Initialize per-category totals for the current exam question set
    resetCategoryStatsForExam();
  } else {
    questionSequence = indices;
  }
}

function resetCategoryStatsForExam() {
  categoryStats = {};
  const catInfo = getCurrentCategoryInfo();
  for (const code in catInfo) {
    categoryStats[code] = { correct: 0, total: 0 };
  }
  if (selectionMode === 'exam' && questionSequence && questionSequence.length > 0) {
    questionSequence.forEach(idx => {
      const q = questions[idx];
      if (q && q.category && categoryStats[q.category]) {
        categoryStats[q.category].total += 1;
      }
    });
  }
}


function getBankHeaderText(q) {
  if (!q || !q.bankID || !q.bankID.trim()) return '';
  const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
  const baseLabel = (currentLanguage === 'fr')
    ? 'ID de question (banque)'
    : 'BankQuestionID';
  const catInfo = getCurrentCategoryInfo();
  let catLabel = null;
  if (q.category && catInfo && catInfo[q.category]) {
    const labelObj = catInfo[q.category];
    catLabel = labelObj[currentLanguage] || labelObj.en || q.category;
  }
  if (catLabel) {
    return `${baseLabel}: ${q.bankID} ‚Äî ${catLabel}`;
  }
  return `${baseLabel}: ${q.bankID}`;
}

function showNextQuestion() {
if (questions.length === 0) return;

// Guard for category mode: require at least one category
if (selectionMode === 'category' && (!categorySelection || categorySelection.size === 0)) {
  alert((UI_STRINGS[currentLanguage] || UI_STRINGS.en).categoryHint || 'Please select one or more categories.');
  return;
}

resetFeedback();
let index;
if (selectionMode === 'norepeat' || selectionMode === 'exam' || selectionMode === 'category') {
  if (!questionSequence || questionSequence.length === 0) {
    resetQuestionSequence();
  }
  if (questionSequence.length === 0) {
    return;
  }
  if (questionSequencePosition >= questionSequence.length) {
    const strings = (UI_STRINGS[currentLanguage] || UI_STRINGS.en);
    if (selectionMode === 'exam') {
      // Exam finished: no more Next Question clicks
      statusEl.textContent = strings.statusExamComplete;
      nextBtn.disabled = true;
      return;
    } else if (selectionMode === 'norepeat') {
      // No-repeat mode finished: all questions used exactly once
      statusEl.textContent = strings.statusAllSeen;
      nextBtn.disabled = true;
      return;
    } else {
      // For category training (or other future modes), keep cycling
      resetQuestionSequence();
      statusEl.textContent = strings.statusAllSeen;
    }
  }
  index = questionSequence[questionSequencePosition++];
} else {
  index = Math.floor(Math.random() * questions.length);
}
currentQuestionIndex = index;
const q = questions[index];


// Show BankQuestionID + category above the question (if present)
if (typeof bankQuestionIdEl !== 'undefined' && bankQuestionIdEl) {
  bankQuestionIdEl.textContent = getBankHeaderText(q);
}

const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
const qText = (currentLanguage === 'fr' && q.question_fr) ? q.question_fr : (q.question_en || q.question);
questionTextEl.innerHTML = qText;
questionCounterEl.textContent = `${strings.questionCounterLabel} ${totalAsked + 1}`;
optionsEl.innerHTML = '';

const opts = (currentLanguage === 'fr' && q.options_fr && q.options_fr.length === 4)
  ? q.options_fr
  : (q.options_en || q.options);

opts.forEach((opt, index) => {
const id = `opt_${index}`;

const label = document.createElement('label');
label.className = 'option-label';
label.setAttribute('data-index', index);

const input = document.createElement('input');
input.type = 'radio';
input.name = 'option';
input.value = index;
input.id = id;

const letter = String.fromCharCode(65 + index);
const span = document.createElement('span');
span.innerHTML = ' ' + letter + ') ' + opt;

label.appendChild(input);
label.appendChild(span);
optionsEl.appendChild(label);
});

checkBtn.disabled = false;
nextBtn.disabled = true;
updateProgressUI();
  saveSessionState();
}


function showCurrentQuestionOnly() {
  if (currentQuestionIndex === null || !questions[currentQuestionIndex]) return;
  const q = questions[currentQuestionIndex];

  if (typeof bankQuestionIdEl !== 'undefined' && bankQuestionIdEl) {
    bankQuestionIdEl.textContent = getBankHeaderText(q);
  }

  const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
  const qText = (currentLanguage === 'fr' && q.question_fr) ? q.question_fr : (q.question_en || q.question);
  questionTextEl.innerHTML = qText;
  if (totalAsked > 0) {
    questionCounterEl.textContent = `${strings.questionCounterLabel} ${totalAsked}`;
  }

  optionsEl.innerHTML = '';
  const opts = (currentLanguage === 'fr' && q.options_fr && q.options_fr.length === 4)
    ? q.options_fr
    : (q.options_en || q.options);

  opts.forEach((opt, index) => {
    const id = `opt_${index}`;
    const label = document.createElement('label');
    label.className = 'option-label';
    label.setAttribute('data-index', index);

    const input = document.createElement('input');
    input.type = 'radio';
    input.name = 'option';
    input.value = index;
    input.id = id;

    const letter = String.fromCharCode(65 + index);
    const span = document.createElement('span');
    span.innerHTML = ' ' + letter + ') ' + opt;

    label.appendChild(input);
    label.appendChild(span);
    optionsEl.appendChild(label);
  });
}

function handleCheckAnswer(event) {
event.preventDefault();
if (currentQuestionIndex === null) return;

const selectedInput = optionsForm.querySelector('input[name="option"]:checked');
if (!selectedInput) {
alert((UI_STRINGS[currentLanguage] || UI_STRINGS.en).selectAnswerPrompt);
return;
}

const selectedIndex = parseInt(selectedInput.value, 10);
const q = questions[currentQuestionIndex];

totalAsked++;
if (selectionMode === 'norepeat' || selectionMode === 'category') {
  cycleAnsweredCount++;
}
const isCorrect = (selectedIndex === q.correctIndex);
if (isCorrect) {
 totalCorrect++;
} else {
 addWrongQuestion(currentQuestionIndex);
}

// Track recent results (last 20)
recentResults.push(isCorrect);
if (recentResults.length > 20) {
  recentResults = recentResults.slice(recentResults.length - 20);
}

// Update per-category stats in exam mode
if (selectionMode === 'exam' && q && q.category && categoryStats && categoryStats[q.category]) {
  if (isCorrect) {
    categoryStats[q.category].correct += 1;
  }
}

highlightOptions(selectedIndex, q.correctIndex);
showFeedback(isCorrect, q);

updateScore();
updateProgressUI();

// At the end of an exam or a no-repeat cycle, disable "Next Question"
const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
if (
  selectionMode === 'exam' &&
  questionSequence &&
  questionSequence.length > 0 &&
  totalAsked >= questionSequence.length
) {
  statusEl.textContent = strings.statusExamComplete;
  nextBtn.disabled = true;
  checkBtn.disabled = true;
  return;
}

if (
  selectionMode === 'norepeat' &&
  questionSequence &&
  questionSequence.length > 0 &&
  cycleAnsweredCount >= questionSequence.length
) {
  statusEl.textContent = strings.statusAllSeen;
  nextBtn.disabled = true;
  checkBtn.disabled = true;
  return;
}

checkBtn.disabled = true;
nextBtn.disabled = false;
}

function addWrongQuestion(questionIndex) {
  if (!wrongQuestionIndices) {
    wrongQuestionIndices = new Set();
  }
  if (typeof questionIndex === 'number' && questionIndex >= 0 && questionIndex < questions.length) {
    wrongQuestionIndices.add(questionIndex);
  }
}


function highlightOptions(selectedIndex, correctIndex) {
const labels = optionsEl.querySelectorAll('.option-label');
labels.forEach(label => {
const idx = parseInt(label.getAttribute('data-index'), 10);
label.classList.remove('correct', 'incorrect');

if (idx === correctIndex) {
label.classList.add('correct');
}
if (idx === selectedIndex && idx !== correctIndex) {
label.classList.add('incorrect');
}
});
}


function showFeedback(isCorrect, questionObj) {
const fStrings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
feedbackEl.textContent = isCorrect ? fStrings.feedbackCorrect : fStrings.feedbackIncorrect;
feedbackEl.className = '';
feedbackEl.classList.add(isCorrect ? 'correct' : 'incorrect');

if (questionObj.explanation) {
// Render explanation as HTML so tables and formatting work
const exLabel = fStrings.explanationLabel || 'Explanation:';
explanationEl.innerHTML = '<strong>' + exLabel + '</strong><br>' + questionObj.explanation;
} else {
explanationEl.innerHTML = '';
}
}

function updateProgressUI() {
  const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
  if (!progressLabelEl || !progressBarInnerEl) return;

  let labelBase = strings.progressLabel || 'Progress';
  let suffix = '';
  let percent = 0;

  if (!questions || questions.length === 0) {
    progressLabelEl.textContent = '';
    progressBarInnerEl.style.width = '0%';
    return;
  }

  if (selectionMode === 'exam' && questionSequence && questionSequence.length > 0) {
    // Exam: progress based on how many questions have actually been answered in this exam set
    percent = questionSequence.length > 0 ? (totalAsked / questionSequence.length) * 100 : 0;
    suffix = strings.progressExamSuffix || '';
  } else if ((selectionMode === 'norepeat' || selectionMode === 'category') && questionSequence && questionSequence.length > 0) {
    // For cycle modes, show how many questions have actually been ANSWERED in this cycle
    percent = questionSequence.length > 0 ? (cycleAnsweredCount / questionSequence.length) * 100 : 0;
    suffix = strings.progressNoRepeatSuffix || '';
  } else if (selectionMode === 'random') {
    // Random mode: show coverage of the whole bank
    percent = questions.length > 0 ? (totalAsked / questions.length) * 100 : 0;
    suffix = strings.progressRandomSuffix || '';
  }

  if (percent < 0) percent = 0;
  if (percent > 100) percent = 100;

  if (selectionMode === 'random') {
    const pctDisplay = isNaN(percent) ? 0 : percent.toFixed(0);
    progressLabelEl.textContent = `${labelBase}: ${totalAsked}/${questions.length} (${pctDisplay}%)`;
  } else if (selectionMode === 'norepeat' || selectionMode === 'category' || selectionMode === 'exam') {
    const pctDisplay = isNaN(percent) ? 0 : percent.toFixed(0);
    progressLabelEl.textContent = `${labelBase}${suffix}: ${pctDisplay}%`;
  } else {
    // Fallback
    progressLabelEl.textContent = `${labelBase}: ${totalAsked}`;
  }

  progressBarInnerEl.style.width = isNaN(percent) ? '0%' : percent + '%';
}


function saveSessionState() {
  try {
    if (!window.localStorage) return;
  } catch (e) {
    return;
  }

  // If no questions are loaded, clear any previous session
  if (!questions || questions.length === 0) {
    try {
      window.localStorage.removeItem('hamExamSession');
    } catch (e) {}
    return;
  }

  const state = {
    v: 1,
    ts: Date.now(),
    examProfile: examProfile,
    selectionMode: selectionMode,
    currentLanguage: currentLanguage,
    currentTheme: currentTheme,
    totalAsked: totalAsked,
    totalCorrect: totalCorrect,
    recentResults: recentResults || [],
    questionSequence: questionSequence || [],
    questionSequencePosition: typeof questionSequencePosition === 'number' ? questionSequencePosition : 0,
    currentQuestionIndex: typeof currentQuestionIndex === 'number' ? currentQuestionIndex : null,
    wrongQuestionIndices: Array.from(wrongQuestionIndices || []),
    categorySelection: Array.from(categorySelection || []),
    categoryStats: categoryStats || {},
    cycleAnsweredCount: typeof cycleAnsweredCount === 'number' ? cycleAnsweredCount : 0,
    lastBankSource: lastBankSource || null,
    lastBankUrl: lastBankUrl || null,
    lastBankFileName: lastBankFileName || null,
    lastBankText: lastBankSource === 'local' ? (lastBankText || null) : null
  };

  try {
    window.localStorage.setItem('hamExamSession', JSON.stringify(state));
  } catch (e) {
    // Ignore quota or serialization errors
  }
}

function clearSessionState() {
  try {
    if (window.localStorage) {
      window.localStorage.removeItem('hamExamSession');
    }
  } catch (e) {}
}

function applyRestoredState(state, parsedQuestions) {
  if (!parsedQuestions || parsedQuestions.length === 0) return;

  questions = parsedQuestions;

  examProfile = state.examProfile || examProfile || 'basic';
  selectionMode = state.selectionMode || 'random';
  currentTheme = state.currentTheme || currentTheme || 'default';

  totalAsked = state.totalAsked || 0;
  totalCorrect = state.totalCorrect || 0;
  recentResults = Array.isArray(state.recentResults) ? state.recentResults : [];
  questionSequence = Array.isArray(state.questionSequence) ? state.questionSequence : [];
  questionSequencePosition = typeof state.questionSequencePosition === 'number'
    ? state.questionSequencePosition
    : 0;
  currentQuestionIndex = (typeof state.currentQuestionIndex === 'number' && state.currentQuestionIndex >= 0)
    ? state.currentQuestionIndex
    : null;
  wrongQuestionIndices = new Set(Array.isArray(state.wrongQuestionIndices) ? state.wrongQuestionIndices : []);
  categorySelection = new Set(Array.isArray(state.categorySelection) ? state.categorySelection : []);
  categoryStats = state.categoryStats || {};
  cycleAnsweredCount = state.cycleAnsweredCount || 0;

  // Restore bank meta
  lastBankSource = state.lastBankSource || null;
  lastBankUrl = state.lastBankUrl || null;
  lastBankFileName = state.lastBankFileName || null;
  lastBankText = state.lastBankSource === 'local' ? (state.lastBankText || null) : null;

  // Reflect selection mode in radios
  if (typeof modeRandomRadio !== 'undefined' && modeRandomRadio) {
    modeRandomRadio.checked = (selectionMode === 'random');
  }
  if (typeof modeNoRepeatRadio !== 'undefined' && modeNoRepeatRadio) {
    modeNoRepeatRadio.checked = (selectionMode === 'norepeat');
  }
  if (typeof modeExamRadio !== 'undefined' && modeExamRadio) {
    modeExamRadio.checked = (selectionMode === 'exam');
  }
  if (typeof modeCategoryRadio !== 'undefined' && modeCategoryRadio) {
    modeCategoryRadio.checked = (selectionMode === 'category');
  }

  // Show quiz card
  if (typeof quizCard !== 'undefined' && quizCard) {
    quizCard.style.display = 'block';
  }

  applyLanguage();
  applyTheme();

  const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
  statusEl.textContent = getLoadedMessageWithProfile(strings);

  updateModeIndicator();
  updateCategoryTrainingVisibility();
  updateScore();
  updateProgressUI();

  if (selectionMode === 'category' && typeof buildCategoryTrainingUI === 'function') {
    buildCategoryTrainingUI();
  }

  if (currentQuestionIndex !== null) {
    showCurrentQuestionOnly();
  } else {
    clearQuestion();
  }

  if (typeof checkBtn !== 'undefined' && checkBtn) {
    checkBtn.disabled = false;
  }
  if (typeof nextBtn !== 'undefined' && nextBtn) {
    nextBtn.disabled = false;
  }

  // Ensure we keep this normalized state
  saveSessionState();
}

function tryRestoreSession() {
  let raw = null;
  try {
    raw = window.localStorage ? window.localStorage.getItem('hamExamSession') : null;
  } catch (e) {
    return;
  }
  if (!raw) return;

  let state = null;
  try {
    state = JSON.parse(raw);
  } catch (e) {
    return;
  }
  if (!state || !state.v) return;

  const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
  const promptText =
    strings.restorePrompt ||
    'A previous session was found. Do you want to continue where you left off?';

  const ok = window.confirm(promptText);
  if (!ok) {
    return;
  }

  // Update meta before attempting reload
  lastBankSource = state.lastBankSource || null;
  lastBankUrl = state.lastBankUrl || null;
  lastBankFileName = state.lastBankFileName || null;
  lastBankText = state.lastBankSource === 'local' ? (state.lastBankText || null) : null;

  if (state.lastBankSource === 'official-basic' ||
      state.lastBankSource === 'official-advanced' ||
      state.lastBankSource === 'official-other') {
    if (!state.lastBankUrl) return;
    statusEl.textContent = strings.statusErrorFile ? strings.statusErrorFile : 'Loading previous session...';
    fetch(state.lastBankUrl)
      .then(resp => {
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        return resp.text();
      })
      .then(txt => {
        const parsed = parseISEDDelimitedQuestions(txt);
        if (!parsed || parsed.length === 0) {
          clearSessionState();
          return;
        }
        applyRestoredState(state, parsed);
      })
      .catch(err => {
        console.error(err);
        clearSessionState();
      });
  } else if (state.lastBankSource === 'local' && state.lastBankText) {
    let parsed = null;
    const lowerName = (state.lastBankFileName || '').toLowerCase();
    try {
      if (lowerName.endsWith('.txt')) {
        parsed = parseISEDDelimitedQuestions(state.lastBankText);
      } else {
        parsed = parseCsvToQuestions(state.lastBankText);
      }
    } catch (e) {
      console.error(e);
      clearSessionState();
      return;
    }
    if (!parsed || parsed.length === 0) {
      clearSessionState();
      return;
    }
    applyRestoredState(state, parsed);
  }
}


function attachWeakAreaHandlers() {
  if (!categoryReportEl) return;
  const buttons = categoryReportEl.querySelectorAll('.weak-practice-btn');
  buttons.forEach(btn => {
    btn.addEventListener('click', () => {
      const code = btn.getAttribute('data-cat');
      if (!code) return;
      startCategoryPracticeFor(code);
    });
  });
}


function attachRetakeWrongHandler() {
  if (!categoryReportEl) return;
  const btn = categoryReportEl.querySelector('#retakeWrongBtn');
  if (!btn) return;
  btn.addEventListener('click', () => {
    const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
    if (!questions || questions.length === 0 || !wrongQuestionIndices || wrongQuestionIndices.size === 0) {
      return;
    }
    // Build a new question sequence containing only the wrong questions
    const indices = Array.from(wrongQuestionIndices);
    if (indices.length === 0) return;

    // Shuffle for variety
    for (let i = indices.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      const tmp = indices[i];
      indices[i] = indices[j];
      indices[j] = tmp;
    }

    selectionMode = 'wrongonly';
    questionSequence = indices;
    questionSequencePosition = 0;

    // Reset exam stats for this retake session
    totalAsked = 0;
    totalCorrect = 0;
    recentResults = [];
    categoryStats = null;

    // Reset score display and qualification/result text
    updateScore();

    // Reset question counter label immediately to 0 for this new session
    if (typeof questionCounterEl !== 'undefined' && questionCounterEl) {
      questionCounterEl.textContent = `${strings.questionCounterLabel} 0`;
    }

    statusEl.textContent = strings.statusRetakeWrong || '';
    resetFeedback();
    clearQuestion();
    updateModeIndicator();
    updateCategoryTrainingVisibility();
    updateProgressUI();
    showNextQuestion();
    scrollToQuizCard();
  });
}

function startCategoryPracticeFor(categoryCode) {
  const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
  if (!questions || questions.length === 0) {
    statusEl.textContent = strings.statusNoFile;
    return;
  }

  // Switch to category training mode
  selectionMode = 'category';
  if (modeCategoryRadio) modeCategoryRadio.checked = true;

  // Rebuild category UI and select only this category
  buildCategoryTrainingUI();
  categorySelection = new Set([categoryCode]);
  const checkboxes = document.querySelectorAll('.cat-checkbox');
  checkboxes.forEach(cb => {
    cb.checked = (cb.value === categoryCode);
    if (cb.checked) {
      categorySelection.add(cb.value);
    }
  });

  statusEl.textContent = getLoadedMessageWithProfile(strings);

  // Reset overall counters so this focused training starts fresh
  totalAsked = 0;
  totalCorrect = 0;
  recentResults = [];
  cycleAnsweredCount = 0;
  updateScore();
updateProgressUI();

  // Reset question counter label immediately to 0 for this focused training
  if (typeof questionCounterEl !== 'undefined' && questionCounterEl) {
    questionCounterEl.textContent = `${strings.questionCounterLabel} 0`;
  }

  // Reset cycle for this focused training and show first question
  resetQuestionSequence();
  resetFeedback();
  clearQuestion();
  updateModeIndicator();
  updateCategoryTrainingVisibility();
  showNextQuestion();
  scrollToQuizCard();
}


function scrollToQuizCard() {
  try {
    const quizCard = document.getElementById('quizCard');
    if (quizCard) {
      quizCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  } catch (e) {
    console.error('scrollToQuizCard error', e);
  }
}


function resetApp() {
  // Scroll to very top
  try {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  } catch (e) {
    window.scrollTo(0, 0);
  }

  // Reset core state (without full page reload)
  questions = [];
  currentQuestionIndex = null;
  totalAsked = 0;
  totalCorrect = 0;
  recentResults = [];
  wrongQuestionIndices = new Set();
  categorySelection = new Set();
  categoryStats = {};
  cycleAnsweredCount = 0;
  examProfile = 'basic';
  selectionMode = 'random';
  questionSequence = [];
  questionSequencePosition = 0;

  // Reset language back to English and radios
  currentLanguage = 'en';
  if (typeof langEnRadio !== 'undefined' && langEnRadio) {
    langEnRadio.checked = true;
  }
  if (typeof langFrRadio !== 'undefined' && langFrRadio) {
    langFrRadio.checked = false;
  }

  // Reset mode radios
  if (typeof modeRandomRadio !== 'undefined' && modeRandomRadio) {
    modeRandomRadio.checked = true;
  }
  if (typeof modeNoRepeatRadio !== 'undefined' && modeNoRepeatRadio) {
    modeNoRepeatRadio.checked = false;
  }
  if (typeof modeExamRadio !== 'undefined' && modeExamRadio) {
    modeExamRadio.checked = false;
  }
  if (typeof modeCategoryRadio !== 'undefined' && modeCategoryRadio) {
    modeCategoryRadio.checked = false;
  }

  // Hide quiz card and clear question UI
  if (typeof quizCard !== 'undefined' && quizCard) {
    quizCard.style.display = 'none';
  }
  if (typeof bankQuestionIdEl !== 'undefined' && bankQuestionIdEl) {
    bankQuestionIdEl.textContent = '';
  }
  if (typeof questionTextEl !== 'undefined' && questionTextEl) {
    questionTextEl.textContent = '';
  }
  if (typeof optionsEl !== 'undefined' && optionsEl) {
    optionsEl.innerHTML = '';
  }
  if (typeof feedbackEl !== 'undefined' && feedbackEl) {
    feedbackEl.textContent = '';
    feedbackEl.className = '';
  }
  if (typeof explanationEl !== 'undefined' && explanationEl) {
    explanationEl.innerHTML = '';
  }
  if (typeof questionCounterEl !== 'undefined' && questionCounterEl) {
    const s = UI_STRINGS.en;
    questionCounterEl.textContent = `${s.questionCounterLabel} 0`;
  }

  // Reset progress UI
  if (typeof progressLabelEl !== 'undefined' && progressLabelEl) {
    progressLabelEl.textContent = '';
  }
  if (typeof progressBarInnerEl !== 'undefined' && progressBarInnerEl) {
    progressBarInnerEl.style.width = '0%';
  }

  // Reset score and reports
  if (typeof scoreEl !== 'undefined' && scoreEl) {
    const s = UI_STRINGS.en;
    scoreEl.textContent = `${s.scorePrefix}: ‚Äì`;
  }
  if (typeof categoryReportEl !== 'undefined' && categoryReportEl) {
    categoryReportEl.innerHTML = '';
  }
  if (typeof recentAccuracyEl !== 'undefined' && recentAccuracyEl) {
    recentAccuracyEl.textContent = '';
  }

  // Reset status
  if (typeof statusEl !== 'undefined' && statusEl) {
    const s = UI_STRINGS.en;
    statusEl.textContent = s.statusNoFile;
  }

  // Disable buttons until a bank is loaded again
  if (typeof checkBtn !== 'undefined' && checkBtn) {
    checkBtn.disabled = true;
  }
  if (typeof nextBtn !== 'undefined' && nextBtn) {
    nextBtn.disabled = true;
  }

  // Re-apply language strings (English baseline after reset)
  applyLanguage();
  clearSessionState();
}


function updateScore() {
  const sStrings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;

  // No questions answered yet: clear score and reports
  if (totalAsked === 0) {
    scoreEl.textContent = `${sStrings.scorePrefix}: ‚Äì`;
    if (categoryReportEl) {
      categoryReportEl.innerHTML = '';
    }
    const memEl0 = document.getElementById('memoryConsolidation');
    if (memEl0) {
      memEl0.innerHTML = '';
    }
    return;
  }

  const percent = (totalCorrect / Math.max(totalAsked, 1)) * 100;
  const percentText = percent.toFixed(1);
  let message = `${sStrings.scorePrefix}: ${totalCorrect} / ${totalAsked} (${percentText}%)`;

  let examFinished = false;

  // Exam-specific handling: only when we have completed the exam sequence
  if (
    selectionMode === 'exam' &&
    questionSequence &&
    questionSequence.length > 0 &&
    typeof questionSequencePosition === 'number' &&
    questionSequencePosition >= questionSequence.length
  ) {
    examFinished = true;
    if (sStrings.statusExamComplete) {
      statusEl.textContent = sStrings.statusExamComplete;
    }

    const p = percent;

    // Official ISED-style wording, based on profile + language
    if (examProfile === 'basic') {
      if (currentLanguage === 'fr') {
        if (p >= 80) {
          message += ' ‚Äî Qualification de base ‚Äî R√©ussite avec mention : ' + percentText + '%';
        } else if (p >= 70) {
          message += ' ‚Äî Qualification de base ‚Äî R√©ussite : ' + percentText + '%';
        } else {
          message += ' ‚Äî Qualification de base ‚Äî √âchec : ' + percentText + '%';
        }
      } else {
        if (p >= 80) {
          message += ' ‚Äî Basic Qualification ‚Äî Pass with Honours: ' + percentText + '%';
        } else if (p >= 70) {
          message += ' ‚Äî Basic Qualification ‚Äî Pass: ' + percentText + '%';
        } else {
          message += ' ‚Äî Basic Qualification ‚Äî Fail: ' + percentText + '%';
        }
      }
    } else if (examProfile === 'advanced') {
      if (currentLanguage === 'fr') {
        if (p >= 70) {
          message += ' ‚Äî Qualification avanc√©e ‚Äî R√©ussite : ' + percentText + '%';
        } else {
          message += ' ‚Äî Qualification avanc√©e ‚Äî √âchec : ' + percentText + '%';
        }
      } else {
        if (p >= 70) {
          message += ' ‚Äî Advanced Qualification ‚Äî Pass: ' + percentText + '%';
        } else {
          message += ' ‚Äî Advanced Qualification ‚Äî Fail: ' + percentText + '%';
        }
      }
    }
  }

  // Build category breakdown and exam review ONLY when an exam has finished
  if (categoryReportEl) {
    if (examFinished && categoryStats) {
      let html = `<h3>${sStrings.catBreakdownTitle}</h3>`;
      html += '<table class="cat-breakdown-table" cellspacing="0">';
      html += `<tr><th>${sStrings.catColCategory}</th><th>${sStrings.catColCorrect}</th><th>${sStrings.catColQuestions}</th><th>${sStrings.catColPercent}</th></tr>`;

      const catInfo = getCurrentCategoryInfo();
      const weakDetails = [];

      if (catInfo) {
        for (const code in catInfo) {
          const st = categoryStats[code] || { correct: 0, total: 0 };
          const pct = st.total > 0 ? Math.round((st.correct / st.total) * 100) : 0;
          const labelObj = catInfo[code];
          const label = labelObj ? (labelObj[currentLanguage] || labelObj.en) : code;

          html += `<tr>
<td>${code} - ${label}</td>
<td>${st.correct}</td>
<td>${st.total}</td>
<td>
  <div class="cat-progress-cell">
    <div class="cat-progress-label">${pct}%</div>
    <div class="cat-progress-outer">
      <div class="cat-progress-inner" style="width:${pct}%;"></div>
    </div>
  </div>
</td>
</tr>`;

          if (st.total > 0 && pct < 70) {
            weakDetails.push({ code, label, pct });
          }
        }
      }

      html += '</table>';

      // Weak areas summary and spotlight
      if (weakDetails.length > 0) {
        const listText = weakDetails
          .map(w => `${w.code} - ${w.label} (${w.pct}%)`)
          .join(', ');
        html += `<p><strong>${sStrings.weakAreasTitle}:</strong> ${listText}</p>`;

        html += '<div id="weakAreasSpotlight">';
        const badgePrefix = sStrings.weakBadgePrefix || '';
        const btnLabel = sStrings.weakPracticeBtn || 'Practice only this category';
        weakDetails.forEach(w => {
          html += `<div class="weak-area-item">
  <span class="weak-badge">‚ùó ${badgePrefix}${w.label} ‚Äî ${w.pct}%</span>
  <button type="button" class="weak-practice-btn" data-cat="${w.code}">${btnLabel}</button>
</div>`;
        });
        html += '</div>';
      } else {
        html += `<p><strong>${sStrings.weakAreasTitle}:</strong> ${sStrings.weakAreasNone}</p>`;
      }

      // Exam review summary: show each question and whether it was correct
      if (selectionMode === 'exam' && questionSequence && questionSequence.length > 0) {
        html += `<h4>${sStrings.examReviewTitle || 'Exam review'}</h4>`;
        html += `<p>${sStrings.examReviewIntro || 'Summary of each question in this exam set:'}</p>`;
        html += '<table class="cat-breakdown-table" cellspacing="0">';
        html += `<tr><th>#</th><th>${sStrings.examReviewColQ || 'Question'}</th><th>${sStrings.examReviewColResult || 'Result'}</th></tr>`;

        questionSequence.forEach((qIndex, idx) => {
          const qObj = questions[qIndex];
          if (!qObj) return;
          const isWrong = wrongQuestionIndices && wrongQuestionIndices.has(qIndex);
          const resultLabel = isWrong
            ? (sStrings.examReviewResultIncorrect || 'Incorrect')
            : (sStrings.examReviewResultCorrect || 'Correct');
          const qText = (currentLanguage === 'fr' && qObj.question_fr)
            ? qObj.question_fr
            : (qObj.question_en || qObj.question);
          const bankIdLabel = qObj.bankID && qObj.bankID.trim() !== ''
            ? ` [${qObj.bankID}]`
            : '';
          html += `<tr>
<td>${idx + 1}</td>
<td>${qText}${bankIdLabel}</td>
<td>${resultLabel}</td>
</tr>`;
        });

        html += '</table>';
      }

      // Offer a retake-wrong-questions session
      if (wrongQuestionIndices && wrongQuestionIndices.size > 0) {
        const wrongCount = wrongQuestionIndices.size;
        html += `<h4>${sStrings.retakeWrongTitle}</h4>`;
        html += `<p>${sStrings.retakeWrongDesc}</p>`;
        html += `<p>${wrongCount} question(s) were answered incorrectly in this exam.</p>`;
        html += `<button type="button" id="retakeWrongBtn" class="btn-primary">${sStrings.retakeWrongBtn}</button>`;
      }

      categoryReportEl.innerHTML = html;
      // Button behavior for weak areas and retake-wrong is handled
      // by the global delegated click handler on categoryReportEl.
    } else {
      // Not exam finished: clear category report in exam mode
      if (selectionMode === 'exam') {
        categoryReportEl.innerHTML = '';
      }
    }
  }

  // Update main score label
  scoreEl.textContent = message;

  // Memory consolidation mini-report every 20 questions
  const memEl = document.getElementById('memoryConsolidation');
  if (memEl) {
    if (totalAsked > 0 && totalAsked % 20 === 0) {
      const catInfo = getCurrentCategoryInfo();
      const weakSummaries = [];

      if (categoryStats && catInfo) {
        for (const code in catInfo) {
          const st = categoryStats[code] || { correct: 0, total: 0 };
          if (st.total === 0) continue;
          const pct = Math.round((st.correct / st.total) * 100);
          if (pct < 70) {
            const labelObj = catInfo[code];
            const label = labelObj ? (labelObj[currentLanguage] || labelObj.en) : code;
            weakSummaries.push(`${code} - ${label} (${pct}%)`);
          }
        }
      }

      if (weakSummaries.length > 0) {
        const heading = currentLanguage === 'fr'
          ? 'Consolidation de la m√©moire ‚Äî zones √† renforcer :'
          : 'Memory consolidation ‚Äî areas to reinforce:';
        const intro = currentLanguage === 'fr'
          ? `Vous avez r√©pondu √† ${totalAsked} questions. Concentrez-vous sur :`
          : `You have answered ${totalAsked} questions. Focus on:`;
        memEl.innerHTML = `<h4>${heading}</h4><p>${intro}</p><ul>` +
          weakSummaries.map(w => `<li>${w}</li>`).join('') +
          '</ul>';
      } else {
        const heading = currentLanguage === 'fr'
          ? 'Consolidation de la m√©moire'
          : 'Memory consolidation';
        const msg = currentLanguage === 'fr'
          ? `Vous avez r√©pondu √† ${totalAsked} questions. Aucune zone faible claire pour le moment ‚Äî continuez comme √ßa !`
          : `You have answered ${totalAsked} questions. No clear weak areas yet ‚Äî keep going!`;
        memEl.innerHTML = `<h4>${heading}</h4><p>${msg}</p>`;
      }
    } else {
      // Clear panel between checkpoints so it only appears at milestones
      memEl.innerHTML = '';
    }
  }
}
function resetFeedback() {
feedbackEl.textContent = '';
feedbackEl.className = '';
explanationEl.innerHTML = '';
}

function clearQuestion() {
bankQuestionIdEl.textContent = '';
questionTextEl.innerHTML = '';
optionsEl.innerHTML = '';
questionCounterEl.textContent = '';
}

</script>
<script>
document.getElementById('darkToggle').addEventListener('click',()=>{
  document.body.classList.toggle('dark');
});
document.getElementById('mobileToggle').addEventListener('click',()=>{
  isMobileMode = !isMobileMode;
  document.body.classList.toggle('mobile-mode', isMobileMode);
  const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
  document.getElementById('mobileToggle').textContent = isMobileMode ? strings.mobileOff : strings.mobileOn;
});

const fullscreenToggleEl = document.getElementById('fullscreenToggle');
if (fullscreenToggleEl) {
  fullscreenToggleEl.addEventListener('click', () => {
    toggleFullscreen();
  });
}

document.addEventListener('fullscreenchange', () => {
  isFullScreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
  const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
  if (fullscreenToggleBtn && strings.fullScreenOn && strings.fullScreenOff) {
    fullscreenToggleBtn.textContent = isFullScreen ? strings.fullScreenOff : strings.fullScreenOn;
  }
});

// Global delegated click handler for category practice & retake-wrong actions
// This ensures the buttons work even after dynamic HTML updates.
if (categoryReportEl) {
  categoryReportEl.addEventListener('click', function (e) {
    const target = e.target;
    if (!target) return;

    // Practice only this category
    if (target.classList.contains('weak-practice-btn')) {
      const code = target.getAttribute('data-cat');
      if (code) {
        startCategoryPracticeFor(code);
      }
      return;
    }

    // Retake only wrong questions
    if (target.id === 'retakeWrongBtn') {
      const strings = UI_STRINGS[currentLanguage] || UI_STRINGS.en;
      if (!questions || questions.length === 0 || !wrongQuestionIndices || wrongQuestionIndices.size === 0) {
        return;
      }

      const indices = Array.from(wrongQuestionIndices);
      if (indices.length === 0) return;

      // Shuffle for variety
      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = indices[i];
        indices[i] = indices[j];
        indices[j] = tmp;
      }

      selectionMode = 'wrongonly';
      questionSequence = indices;
      questionSequencePosition = 0;

      // Reset stats for this focused retake session
      totalAsked = 0;
      totalCorrect = 0;
      recentResults = [];
      categoryStats = null;

      statusEl.textContent = strings.statusRetakeWrong || '';
      resetFeedback();
      clearQuestion();
      updateModeIndicator();
      updateCategoryTrainingVisibility();
      updateProgressUI();
      showNextQuestion();
    }
  });
}

</script>


<div class="card" id="supportCard">
  <h2 id="supportTitle">About &amp; Support</h2>
  <p id="supportText">
    This free bilingual HAM exam trainer was created to help students prepare using real-style questions,
    official exam structures, and category statistics. It is licensed under CC BY-NC-SA 4.0 (non-commercial, attribution, share-alike).
    You may use and share it for personal or educational purposes, but not resell it or include it in paid products or services.
    If this app helps you, you can support future improvements.
  </p>
  <p id="supportExtra"></p>
  <div id="supportLinks" class="controls" style="margin-top:8px;">
    <a id="supportButton" href="https://buymeacoffee.com/fabiolus" target="_blank" rel="noopener noreferrer"
       style="display:inline-block;padding:8px 14px;border-radius:6px;border:1px solid #c98b00;
              background:#ffd24d;color:#000;font-weight:bold;text-decoration:none;">
      ‚òï Buy me a coffee
    </a>
    <a id="supportIssueLink" href="https://github.com/Fabiolus2020/HamExamTrainer2025/issues" target="_blank" rel="noopener noreferrer"
       style="display:inline-block;padding:8px 14px;border-radius:6px;border:1px solid #888;
              background:#f2f2f2;color:#000;font-weight:bold;text-decoration:none;">
      üêû Report an issue
    </a>
    <a id="supportReadmeLink" href="https://raw.githubusercontent.com/Fabiolus2020/HamExamTrainer2025/main/README.md" target="_blank" rel="noopener noreferrer"
       style="display:inline-block;padding:8px 14px;border-radius:6px;border:1px solid #888;
              background:#f2f2f2;color:#000;font-weight:bold;text-decoration:none;">
      üìò View README
    </a>
  </div>
</div>
</div>

<script>
// PWA service worker registration
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('sw.js').catch(err => {
      console.error('Service worker registration failed:', err);
    });
  });
}
</script>

<footer id="licenseFooter" style="margin-top:12px;font-size:0.75rem;color:#777;text-align:center;">
  Licensed under CC BY-NC-SA 4.0 &ndash; Non-commercial use only
</footer>

</body>
</html>
